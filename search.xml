<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[秘密共享及门限签名]]></title>
    <url>%2F2019%2F05%2F14%2F%E7%A7%98%E5%AF%86%E5%85%B1%E4%BA%AB%E5%8F%8A%E9%97%A8%E9%99%90%E7%AD%BE%E5%90%8D%2F</url>
    <content type="text"><![CDATA[Elgamal 签名算法 $\rightarrow$ Harn 的门限签名方案 Asmuth-Bloom 法 Elgamal 签名算法依赖有限域上的离散指数的难计算性，即设$g$为素数$p$的模循环群的原根，对任意的$a$，计算： $$b=g^a\bmod p$$ 是容易的（通过幂取模算法）。反过来，给定$b$计算满足上式的$a$是非常困难的，$a$称为以$g$为基$b$的离散对数。 初始化Alice随机选择大素数$p$和$1$到$p$之间的整数$x$，找出有限域$Z_p$的一个生成元$g$，计算： $$y=g^x\bmod p$$ 则公钥为$y$，私钥为$x$。 签名设待签名消息为$m$，Alice随机选择整数$k$，满足$k&lt;p$，$gcd(k,p-1)=1$。计算： $$r=g^k\bmod p$$$$s=(m-xr)k^{-1}\bmod p$$ 将$m$的签名$(r,s)$发送给Bob。 验证Bob收到$(r,s)$，利用Alice的公钥$y$验证等式： $$g^m\equiv y^rr^s\bmod p$$ 若等式成立则签名有效。 Harn 的门限签名方案初始化假设有$n$个成员$P_1,P_2,…P_n$，$t$为门限值，$p$、$q$为大素数，$q|(p-1)$，$g$为有限域$Z_p$上的$q$阶生成元，$h$是$g$的循环群中的一个数，待签名消息为$m$，每个成员随机选择$z_i$和$x_i$，计算： $$y_i=g^{z_i}\bmod p$$ 成员$P_i$私钥为$z_i$，组公钥$y$计算如下： $$y=\prod_{i=1}^ny_i\bmod p$$ $P_i(i=1,2,…,n)$选取一个$t-1$次多项式：$f_i(x)=z_i+a_{i,1}x+a_{i,2}x^2+…+a_{i,t-1}x^{t-1}$，计算影子份额$f_i(x_j)\bmod q$发送给$P_j$，并计算验证信息： $$y_{i,j}=g^{f_i(x_j)}\bmod p$$ 产生部分签名设参与签名的成员$P_1,P_2,…P_t$。成员$P_i(i=1,2,…,t)$选择一个随机数$k_i\in[1,q-1]$，计算$r_i=g^{k_i}\bmod p$并将其广播给所有成员。 收到其他成员广播的$r_i$后，$P_i$计算 $$r=\prod_{i=1}^tr_i\bmod p$$ 通过自己的私钥$z_i$、$k_i$、份额$f_j(x_i)(j=t+1,t+2,…,n)$计算： $$s_i=z_i+\lbrace\sum_{j=t+1}^nf_j(x_i)(\prod_{k=1,k\neq i}^t\frac{-x_k}{x_k-x_j})\rbrace m-k_i r\bmod q$$ 将部分签名$(r_i,s_i)$发送给签名合成者。 合成者收到$\lbrace r_i,s_i\rbrace$后，通过下式验证其有效性： $$\lbrace y_i(\prod_{j=t+1}^ny_{j,i})^{\prod_{k=1,k\neq i}^t\frac{-x_k}{x_i-x_k}}\rbrace^m=r_i^r g^{s_j}\bmod p$$ 若验证式成立，则收到的部分签名$\lbrace r_i,s_i\rbrace$有效。 产生组签名合成者确认接收到$t$个正确的部分签名后，计算： $$s=\sum_{i=1}^ts_i\bmod q$$ 将$\lbrace r,s\rbrace$作为消息$m$的组签名。 验证签名验证者收到组签名后，验证其有效性： $$y^m=r^r g^s \bmod p$$ Asmuth-Bloom 法初始化假设$S$为共享秘密，$DCA$为秘密分发者，有$n$个成员$P_1,P_2,…,P_n$，$t$为恢复秘密的门限值。$DC$选择大素数$q$和严格递增的序列$d=\lbrace d_1,d_2,…,d_n\rbrace$，$d$满足如下条件： $$d_1&lt;d_2&lt;…&lt;d_n$$ $$(d_i,d_j)=1,(i\neq j)$$ $$(d_i,q)=1,(i=1,2,…,n)$$ $$\prod_{i=1}^td_i&gt;q\prod_{i=1}^{t-1}d_{n-i+1}$$ 秘密分发令$M=\prod_{i=1}^td_i$，选择满足式$0\leq A\leq \frac{M}{q}-1$的整数$A$，$DC$计算： $$Z=S+Aq$$ $$Z_i=Z\bmod d_i,i=1,2,…n$$ 并将$(Z_i,d_i)$作为秘密份额发给成员$P_i,(i=1,2,…,n)$。 秘密恢复选取$t$个成员$\lbrace P_1,P_2,…,P_t\rbrace$参与秘密的恢复，通过交换秘密份额，任意成员$P_i$可以建立同余方程组： $$\begin{cases}Z_1=Z\bmod d_1 \Z_2=Z\bmod d_2 \\vdots \Z_t=Z\bmod d_t\end{cases}$$ 由$CRT$可知该方程组有唯一解： $$Z=\sum_{i=1}^t\frac{D}{d_i}\cdot e_i\cdot Z_i\bmod D,i=1,2,..,t$$ 其中： $$D=\prod_{i=1}^td_i$$ $$\frac{D}{d_i}\cdot e_i \equiv 1\bmod d_i,i=1,2,…,t$$ 可求出共享秘密$S=Z\bmod q$。]]></content>
      <categories>
        <category>密码学基础</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>数字签名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破解 PS4 - 第一部分：PS4 安全和用户态 ROP 简介]]></title>
    <url>%2F2019%2F05%2F06%2F%E7%A0%B4%E8%A7%A3-PS4-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[原文标题 Hacking the PS4, part 1 Introduction to PS4’s security, and userland ROP (日期未知) 作者：CTurt 由于目前很长时间没有关于 PS4 破解的重大公告，我想解释一下 PS4 破解已经走了多远，以及阻止它进一步发展的原因。 我将解释一些通用于所有现代系统的安全概念，以及我在 PS4 上运行 ROP 测试所做的发现。 本系列文章的目标是展示完整的漏洞利用链，从访问 Internet 浏览器的网页，到最终在 PS4 上实现内核代码执行。 如果您对漏洞挖掘不是特别熟悉，那么您应该先阅读我的关于通过保存文件中的栈粉碎漏洞来破解 DS 游戏的文章。 您可以在此下载我的完整设置以自行运行这些测试；它目前仅适用于固件 1.76。如果您正在使用较旧的固件并希望更新到 1.76，则可以下载 1.76 PUP 文件并通过 USB 更新。 PS4 背景 您可能知道 PS4 使用的是定制的 AMD x86-64 CPU（8核），即使此特定版本可能与已知标准稍有不同，目前仍有许多研究成果可用于此 CPU 架构。 例如，PFLA（Page Fault Liberation Army）在 29C3 大会期间发布了仅使用页错误和 x86 MMU 实现完整图灵机的概念证明，您可以在 YouTube 上查看他们的精彩视频。 如果您尝试在虚拟机中运行代码并希望在主机 CPU 上执行指令，也会很有趣。 – EurAsia 新闻 3251 号文章 除了表现良好的 CPU 架构外，PS4 中使用的大部分软件都是开源的。 最值得注意的是，PS4 的 Orbis OS 基于 FreeBSD 9.0，就像 PS3 的操作系统一样（也有部分 NetBSD）；并包括各种许多其他开源软件，如 Mono VM 和 WebKit。 从 WebKit 入手WebKit 是开源的布局引擎，它被用于 iOS，Wii U，3DS，PS Vita 和 PS4 的浏览器中来呈现网页。 尽管 WebKit 被广泛使用，但它确实存在漏洞；通过阅读 Pwn2Own write-ups，你可以了解其中的许多内容。 特别是 PS4 1.76 版本固件中的浏览器使用的 WebKit 版本易受到 CVE-2012-3748 的攻击，这是由 JSArray :: sort(...) 方法中基于堆的缓冲区溢出造成的。 2014年，NAS 和 Proxima 宣布他们已经成功地将一个利用该漏洞破解 Mac OS X Safari 代码移植到 PS4 的浏览器，并公布了作为破解 PS4 第一个入口点的 PoC 代码。 这使我们可以任意读写 WebKit 进程可以读取和写入的内容，这些内容可以用于转储模块，并覆盖栈上的返回地址，让我们控制指令指针寄存器（rip）来实现 RO P执行。 从那时起，WebKit 中发现了许多其他漏洞，这些漏洞可能被用作 PS4 后期固件的入口点，但截至撰写时，没有人公开宣称将任何这些漏洞利用代码移植到 PS4。 如果您从未登录 PSN，您的 PS4 将无法打开 Internet 浏览器，但您可以转到“设置”，然后选择“用户指南”打开功能有限的 Web 浏览器视图，您可以用代理控制其中的内容。 ROP 是什么？与 DS 等早期设备不同，PS4 有一个内核来控制内存不同区域的属性。其中标记为可执行的内存页面不能被覆写，并且标记为可写的内存页面不能被执行; 这称为数据执行保护（DEP）。 这意味着我们不能只将有效负载复制到内存中并执行。但是，我们可以执行已加载到内存中并标记为可执行的代码。 如果我们不能将自己的代码编写到某个地址地址，那么跳转到该地址并不是非常有用，因此我们使用 ROP。 ROP（Return-Oriented Programming）是传统栈粉碎技术的扩展，我们可以将许多不同的地址（称为 gadgets）链接在一起，而不是仅覆盖 rip 将跳转到的单个值。 一条 gadget 通常只是一个所需的指令以及一个 ret。 在 x86_64 程序集中，当到达 ret 指令时，程序会从栈中弹出一个 64 位的值并且将 rip 跳转到它；由于我们可以控制堆栈，所以我们可以使每个 ret 指令跳转到下一个所需的 gadget。 例如 0x80000 处： mov rax, 0 ret 0x90000 处： mov rbx, 0 ret If we overwrite a return address on the stack to contain 0x80000 followed by 0x90000, then as soon as the first ret instruction is reached execution will jump to mov rax, 0, and immediately afterwards, the next ret instruction will pop 0x90000 off the stack and jump to mov rbx, 0. Effectively this chain will set both rax and rbx to 0, just as if we had written the code into a single location and executed it from there. ROP chains aren’t just limited to a list of addresses though; assuming that from 0xa0000 contains these instructions: pop rax ret We can set the first item in the chain to 0xa0000 and the next item to any desired value for rax. Gadgets also don’t have to end in a ret instruction; we can use gadgets ending in a jmp: add rax, 8 jmp rcx By making rcx point to a ret instruction, the chain will continue as normal: chain.add(&quot;pop rcx&quot;, &quot;ret&quot;); chain.add(&quot;add rax, 8; jmp rcx&quot;); Sometimes you won’t be able to find the exact gadget that you need on its own, but with other instructions after it. For example, if you want to set r8 to something, but only have this gadget, you will have to set r9 to some dummy value: pop r8 pop r9 ret Although you may have to be creative with how you write ROP chains, it is generally accepted that within a sufficiently large enough code dump, there will be enough gadgets for Turing-complete functionality; this makes ROP a viable method of defeating DEP. 寻找 gadgetsThink of ROP as writing a new chapter to a book, using only words that have appeared at the end of sentences in the previous chapters. It’s obvious from the structure of most sentences that we probably won’t be able to find words like ‘and’ or ‘but’ appearing at the end of any sentences, but we will need these connectives in order to write anything meaningful. It is quite possible however, that a sentence has ended with ‘sand’. Although the author only ever intended for the word to be read from the ‘s’, if we start reading from the ‘a’, it will appear as an entirely different word by coincidence, ‘and’. These principles also apply to ROP. Since almost all functions are structured with a prologue and epilogue: ; Save registers push rbp mov rbp, rsp push r15 push r14 push r13 push r12 push rbx sub rsp, 18h ; Function body ; Restore registers add rsp, 18h pop rbx pop r12 pop r13 pop r14 pop r15 pop rbp ret You’d expect to only be able to find pop gadgets, or more rarely, something like xor rax, rax to set the return value to 0 before returning. Having a comparison like: cmp [rax], r12 ret Wouldn’t make any sense since the result of the comparison isn’t used by the function. However, there is still a possibility that we can find gadgets like these. x86_64 instructions are similar to words in that they have variable lengths, and can mean something entirely different depending on where decoding starts. The x86_64 architecture is a variable-length CISC instruction set. Return-oriented programming on the x86_64 takes advantage of the fact that the instruction set is very “dense”, that is, any random sequence of bytes is likely to be interpretable as some valid set of x86_64 instructions. – Wikipedia To demonstrate this, take a look at the end of this function from the WebKit module: 000000000052BE0D mov eax, [rdx+8] 000000000052BE10 mov [rsi+10h], eax 000000000052BE13 or byte ptr [rsi+39h], 20h 000000000052BE17 ret Now take a look at what the code looks like if we start decoding from 0x52be14: 000000000052BE14 cmp [rax], r12 000000000052BE17 ret Even though this code was never intended to be executed, it is within an area of memory which has been marked as executable, so it is perfectly valid to use as a gadget. Of course, it would be incredibily time consuming to look at every possible way of interpreting code before every single ret instruction manually; and that’s why tools exist to do this for you. The one which I use to search for ROP gadgets is rp++; to generate a text file filled with gadgets, just use: rp-win-x64 -f mod14.bin --raw=x64 --rop=1 --unique &gt; mod14.txt General protection faultsIf we _do_ perform an access violation, such as by trying to execute a non-executable page of memory, or by trying to write to a non-writable page of memory, a general protection fault, or more specifically in this instance, a segmentation fault, will occur. For example, trying to execute code on the stack, which is mapped as read and write only: setU8to(chain.data + 0, 0xeb); setU8to(chain.data + 1, 0xfe); chain.add(chain.data); And trying to write to code, which is mapped as read and execute only: setU8to(moduleBases[webkit], 0); If a general protection fault occurs, a message saying “There is not enough free system memory” will appear, and the page will fail to load: This message will also be displayed for other hard faults, such as division by 0, or execution of an invalid instruction or unimplemented system call, but most commonly it will be encountered by performing a segmentation fault. ASLRAddress Space Layout Randomization (ASLR) is a security technique which causes the base addresses of modules to be different every time you start the PS4. It has been reported to me that very old firmwares (1.05) don’t have ASLR enabled, but it was introduced sometime before firmware 1.70. Note that kernel ASLR is not enabled (for firmwares 1.76 and lower at least), which will be proved later in the article. For most exploits ASLR would be a problem because if you don’t know the addresses of the gadgets in memory, you would have no idea what to write to the stack. Luckily for us, we aren’t limited to just writing static ROP chains. We can use JavaScript to read the modules table, which will tell us the base addresses of all loaded modules. Using these bases, we can then calculate the addresses of all our gadgets before we trigger ROP execution, defeating ASLR. The modules table also includes the filenames of the modules: WebProcess.self libkernel.sprx libSceLibcInternal.sprx libSceSysmodule.sprx libSceNet.sprx libSceNetCtl.sprx libSceIpmi.sprx libSceMbus.sprx libSceRegMgr.sprx libSceRtc.sprx libScePad.sprx libSceVideoOut.sprx libScePigletv2VSH.sprx libSceOrbisCompat.sprx libSceWebKit2.sprx libSceSysCore.sprx libSceSsl.sprx libSceVideoCoreServerInterface.sprx libSceSystemService.sprx libSceCompositeExt.sprx Although the PS4 predominantly uses the [Signed] PPU Relocatable Executable ([S]PRX) format for modules, some string references to [Signed] Executable and Linking Format ([S]ELF) object files can also be found in the libSceSysmodule.sprx dump, such as bdj.elf, web_core.elf and orbis-jsc-compiler.self. This combination of modules and objects is similar to what is used in the PSP and PS3. You can view a complete list of all modules available (not just those loaded by the browser) in libSceSysmodule.sprx. We can load and dump some of these through several of Sony’s custom system calls, which will be explained later in this article. JuSt-ROPUsing JavaScript to write and execute dynamic ROP chains gives us a tremendous advantage over a traditional, static buffer overflow attack. As well as being necessary to defeat ASLR, JavaScript also lets us read the user agent of the browser, and provide different ROP chains for different browser versions, giving our exploit a greater range of compatibility. We can even use JavaScript to read the memory at our gadgets’ addresses to check that they are correct, giving us almost perfect reliability. Theoretically, you could take this even further by writing a script to dynamically find ROP gadgets and then build ROP chains on the fly. Writing ROP chains dynamically, rather than generating them with a script beforehand, just makes sense. I created a JavaScript framework for writing ROP chains, JuSt-ROP, for this very reason. JavaScript caveatsJavaScript represents numbers using the IEEE-754 double-precision (64 bit) format. This provides us with 53 bit precision, meaning that it isn’t possible to represent every 64 bit value, approximations will have to be used for some. If you just need to set a 64 bit value to something low, like 256, then setU64to will be fine. But for situations in which you need to write a buffer or struct of data, there is the possibility that certain bytes will be written incorrectly if it has been written in 64 bit chunks. Instead, you should write data in 32 bit chunks (remembering that the PS4 is little endian), to ensure that every byte is exact. 系统调用Interestingly, the PS4 uses the same calling convention as Linux and MS-DOS for system calls, with arguments stored in registers, rather than the traditional UNIX way (which FreeBSD uses by default), with arguments stored in the stack: rax - System call number rdi - Argument 1 rsi - Argument 2 rdx - Argument 3 r10 - Argument 4 r8 - Argument 5 r9 - Argument 6 We can try to perform any system call with the following JuSt-ROP method: this.syscall = function(name, systemCallNumber, arg1, arg2, arg3, arg4, arg5, arg6) { console.log(&quot;syscall &quot; + name); this.add(&quot;pop rax&quot;, systemCallNumber); if(typeof(arg1) !== &quot;undefined&quot;) this.add(&quot;pop rdi&quot;, arg1); if(typeof(arg2) !== &quot;undefined&quot;) this.add(&quot;pop rsi&quot;, arg2); if(typeof(arg3) !== &quot;undefined&quot;) this.add(&quot;pop rdx&quot;, arg3); if(typeof(arg4) !== &quot;undefined&quot;) this.add(&quot;pop rcx&quot;, arg4); if(typeof(arg5) !== &quot;undefined&quot;) this.add(&quot;pop r8&quot;, arg5); if(typeof(arg6) !== &quot;undefined&quot;) this.add(&quot;pop r9&quot;, arg6); this.add(&quot;mov r10, rcx; syscall&quot;); } Just make sure to set the stack base to some free memory beforehand: this.add(&quot;pop rbp&quot;, stackBase + returnAddress + 0x1400); Using system calls can tell us a huge amount about the PS4 kernel. Not only that, but using system calls is most likely the only way that we can interact with the kernel, and thus potentially trigger a kernel exploit. If you are reverse engineering modules to identify some of Sony’s custom system calls, you may come across an alternative calling convention: Sometimes Sony performs system calls through regular system call 0 (which usually does nothing in FreeBSD), with the first argument (rdi) controlling which system call should be executed: rax - 0 rdi - System call number rsi - Argument 1 rdx - Argument 2 r10 - Argument 3 r8 - Argument 4 r9 - Argument 5 It is likely that Sony did this to have easy compatibility with the function calling convention. For example: .global syscall syscall: xor rax, rax mov r10, rcx syscall ret Using this, they can perform system calls from C using the function calling convention: int syscall(); int getpid(void) { return syscall(20); } When writing ROP chains, we can use either convention: // Both will get the current process ID: chain.syscall(&quot;getpid&quot;, 20); chain.syscall(&quot;getpid&quot;, 0, 20); It’s good to be aware of this, because we can use whichever one is more convenient for the gadgets that are available. getpidJust by using system call 20, getpid(void), we can learn a lot about the kernel. The very fact that this system call works at all tells us that Sony didn’t bother mixing up the system call numbers as a means of security through obscurity (under the BSD license they could have done this without releasing the new system call numbers). So, we automatically have a list of system calls in the PS4 kernel to try. Secondly, by calling getpid(), restarting the browser, and calling it again, we get a return value 2 higher than the previous value. This tells us that the Internet Browser app actually consists of 2 separate processes: the WebKit core (which we take over), that handles parsing HTML and CSS, decoding images, and executing JavaScript for example, and another one to handle everything else: displaying graphics, receiving controller input, managing history and bookmarks, etc. Also, although FreeBSD has supported PID randomisation since 4.0, sequential PID allocation is the default behaviour. The fact that PID allocation is set to the default behaviour indicates that Sony likely didn’t bother adding any additional security enhancements such as those encouraged by projects like HardenedBSD, other than userland ASLR. How many custom system calls are there?The last standard FreeBSD 9 system call is wait6, number 532; anything higher than this must be a custom Sony system call. Invoking most of Sony’s custom system calls without the correct arguments will return error 0x16, &quot;Invalid argument&quot;; however, any compatibility or unimplemented system calls will report the “There is not enough free system memory” error. Through trial and error, I have found that system call number 617 is the last Sony system call, anything higher is unimplemented. From this, we can conclude that there are 85 custom Sony system calls in the PS4’s kernel (617 - 532). libkernel.sprxTo identify how custom system calls are used by libkernel, you must first remember that it is just a modification of the standard FreeBSD 9.0 libraries. Here’s an extract of _libpthread_init from thr_init.c: /* * Check for the special case of this process running as * or in place of init as pid = 1: */ if ((_thr_pid = getpid()) == 1) { /* * Setup a new session for this process which is * assumed to be running as root. */ if (setsid() == -1) PANIC(&quot;Can&apos;t set session ID&quot;); if (revoke(_PATH_CONSOLE) != 0) PANIC(&quot;Can&apos;t revoke console&quot;); if ((fd = __sys_open(_PATH_CONSOLE, O_RDWR)) &amp;lt; 0) PANIC(&quot;Can&apos;t open console&quot;); if (setlogin(&quot;root&quot;) == -1) PANIC(&quot;Can&apos;t set login to root&quot;); if (_ioctl(fd, TIOCSCTTY, (char *) NULL) == -1) PANIC(&quot;Can&apos;t set controlling terminal&quot;); } The same function can be found at offset 0x215F0 from libkernel.sprx. This is how the above extract looks from within a libkernel dump: call getpid mov cs:dword_5B638, eax cmp eax, 1 jnz short loc_2169F call setsid cmp eax, 0FFFFFFFFh jz loc_21A0C lea rdi, aDevConsole ; &quot;/dev/console&quot; call revoke test eax, eax jnz loc_21A24 lea rdi, aDevConsole ; &quot;/dev/console&quot; mov esi, 2 xor al, al call open mov r14d, eax test r14d, r14d js loc_21A3C lea rdi, aRoot ; &quot;root&quot; call setlogin cmp eax, 0FFFFFFFFh jz loc_21A54 mov edi, r14d mov esi, 20007461h xor edx, edx xor al, al call ioctl cmp eax, 0FFFFFFFFh jz loc_21A6C Reversing module dumps to analyse system callslibkernel isn’t completely open source though; there’s also a lot of custom code which can help disclose some of Sony’s system calls. Although this process will vary depending on the system call you are looking up; for some, it is fairly easy to get a basic understanding of the arguments that are passed to it. The system call wrapper will be declared somewhere in libkernel.sprx, and will almost always follow this template: 000000000000DB70 syscall_601 proc near 000000000000DB70 mov rax, 259h 000000000000DB77 mov r10, rcx 000000000000DB7A syscall 000000000000DB7C jb short error 000000000000DB7E retn 000000000000DB7F 000000000000DB7F error: 000000000000DB7F lea rcx, sub_DF60 000000000000DB86 jmp rcx 000000000000DB86 syscall_601 endp Note that the mov r10, rcx instruction doesn’t necessarily mean that the system call takes at least 4 arguments; all system call wrappers have it, even those that take no arguments, such as getpid. Once you’ve found the wrapper, you can look up xrefs to it: 0000000000011D50 mov edi, 10h 0000000000011D55 xor esi, esi 0000000000011D57 mov edx, 1 0000000000011D5C call syscall_601 0000000000011D61 test eax, eax 0000000000011D63 jz short loc_11D6A It’s good to look up several of these, just to make sure that the registers weren’t modified for something unrelated: 0000000000011A28 mov edi, 9 0000000000011A2D xor esi, esi 0000000000011A2F xor edx, edx 0000000000011A31 call syscall_601 0000000000011A36 test eax, eax 0000000000011A38 jz short loc_11A3F Consistently, the first three registers of the system call convention (rdi, rsi, and rdx) are modified before invoking the call, so we can conclude with reasonable confidence that it takes 3 arguments. For clarity, this is how we would replicate the calls in JuSt-ROP: chain.syscall(&quot;unknown&quot;, 601, 0x10, 0, 1); chain.syscall(&quot;unknown&quot;, 601, 9, 0, 0); As with most system calls, it will return 0 on success, as seen by the jz conditional after testing the return value. Looking up anything beyond than the amount of arguments will require a much more in-depth analysis of the code before and after the call to understand the context, but this should help you get started. Brute forcing system callsAlthough reverse engineering module dumps is the most reliable way to identify system calls, some aren’t referenced at all in the dumps we have so we will need to analyse them blindly. If we guess that a certain system call might take a particular set of arguments, we can brute force all system calls which return a certain value (0 for success) with the arguments that we chose, and ignore all which returned an error. We can also pass 0s for all arguments, and brute force all system calls which return useful errors such as 0xe, &quot;Bad address&quot;, which would indicate that they take at least one pointer. Firstly, we will need to execute the ROP chain as soon as the page loads. We can do this by attaching our function to the body element’s onload: &lt;body onload=&quot;exploit()&quot;&gt; Next we will need to perform a specific system call depending on an HTTP GET value. Although this can be done with JavaScript, I will demonstrate how to do this using PHP for simplicity: var Sony = 533; chain.syscall(&quot;Sony system call&quot;, Sony + &amp;lt;?php print($_GET[&quot;b&quot;]); ?&amp;gt;, 0, 0, 0, 0, 0, 0); chain.write_rax_ToVariable(0); Once the system call has executed, we can check the return value, and if it isn’t interesting, redirect the page to the next system call: if(chain.getVariable(0) == 0x16) window.location.assign(&quot;index.php?b=&quot; + (&amp;lt;?php print($_GET[&quot;b&quot;]); ?&amp;gt; + 1).toString()); Running the page with ?b=0 appended to the end will start the brute force from the first Sony system call. Although this method requires a lot of experimentation, by passing different values to some of the system calls found by brute forcing and analysing the new return values, there are a few system calls which you should be able to partially identify. System call 538As an example, I’ll take a look at system call 538, without relying on any module dumps. These are the return values depending on what is passed as the first argument: 0 - 0x16, &quot;Invalid argument&quot; 1 - 0xe, &quot;Bad address&quot; Pointer to 0s - 0x64 initially, but each time the page is refreshed this value increases by 1 Other potential arguments to try would be PID, thread ID, and file descriptor. Although most system calls will return 0 on success, due to the nature of the return value increasing after each time it is called, it seems like it is allocating a resource number, such as a file descriptor. The next thing to do would be to look at the data before and after performing the system call, to see if it has been written to. Since there is no change in the data, we can assume that it is an input for now. I then tried passing a long string as the first argument. You should always try this with every input you find because there is the possibility of discovering a buffer overflow. writeString(chain.data, &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;); chain.syscall(&quot;unknown&quot;, 538, chain.data, 0, 0, 0, 0, 0); The return value for this is 0x3f, ENAMETOOLONG. Unfortunately it seems that this system call correctly limits the name (32 bytes including NULL truncator), but it does tell us that it _is_ expecting a string, rather than a struct. We now have a few possibilities for what this system call is doing, the most obvious being something related to the filesystem (such as a custom mkdir or open), but this doesn’t seem particularly likely seeing as a resource was allocated even before we wrote any data to the pointer. To test whether the first parameter is a path, we can break it up with multiple / characters to see if this allows for a longer string: writeString(chain.data, &quot;aaaaaaaaaa/aaaaaaaaaa/aaaaaaaaaa&quot;); chain.syscall(&quot;unknown&quot;, 538, chain.data, 0, 0, 0, 0, 0); Since this also returns 0x3f, we can assume that the first argument isn’t a path; it is a name for something that gets allocated a sequential identifier. After analysing some more system calls, I found that the following all shared this exact same behaviour: 533 538 557 574 580 From the information that we have so far, it is almost impossible to pinpoint exactly what these system calls do, but as you run more tests, further information will slowly be revealed. To save you some time, system call 538 is allocating an event flag (and it doesn’t just take a name). Using general knowledge of how a kernel works, you can guess, and then verify, what the system calls are allocating (semaphores, mutexes, etc). Dumping additional modulesWe can dump additional modules by following these stages: Load the module Get the module’s base address Dump the module I’ve extracted and posted a list of all module names on psdevwiki. To load a module we will need to use the sceSysmoduleLoadModule function from libSceSysmodule.sprx + 0x1850. The first parameter is the module ID to load, and the other 3 should just be passed 0. The following JuSt-ROP method can be used to perform a function call: this.call = function(name, module, address, arg1, arg2, arg3, arg4, arg5, arg6) { console.log(&quot;call &quot; + name); if(typeof(arg1) !== &quot;undefined&quot;) this.add(&quot;pop rdi&quot;, arg1); if(typeof(arg2) !== &quot;undefined&quot;) this.add(&quot;pop rsi&quot;, arg2); if(typeof(arg3) !== &quot;undefined&quot;) this.add(&quot;pop rdx&quot;, arg3); if(typeof(arg4) !== &quot;undefined&quot;) this.add(&quot;pop rcx&quot;, arg4); if(typeof(arg5) !== &quot;undefined&quot;) this.add(&quot;pop r8&quot;, arg5); if(typeof(arg6) !== &quot;undefined&quot;) this.add(&quot;pop r9&quot;, arg6); this.add(module_bases[module] + address); } So, to load libSceAvSetting.sprx (0xb): chain.call(&quot;sceSysmoduleLoadModule&quot;, libSysmodule, 0x1850, 0xb, 0, 0, 0); Unfortunately, a fault will be triggered when trying to load certain modules; this is because the sceSysmoduleLoadModule function doesn’t load dependencies, so you will need to manually load them first. Like most system calls, this should return 0 on success. To see the loaded module ID that was allocated, we can use one of Sony’s custom system calls, number 592, to get a list of currently loaded modules: var countAddress = chain.data; var modulesAddress = chain.data + 8; // System call 592, getLoadedModules(int *destinationModuleHandles, int max, int *count); chain.syscall(&quot;getLoadedModules&quot;, 592, modulesAddress, 256, countAddress); chain.execute(function() { var count = getU64from(countAddress); for(var index = 0; index &amp;lt; count; index++) { logAdd(&quot;Module handle: 0x&quot; + getU32from(modulesAddress + index * 4).toString(16)); } }); Running this without loading any additional modules will produce the following list: 0x0, 0x1, 0x2, 0xc, 0xe, 0xf, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1e, 0x37, 0x59 But if we run it after loading module 0xb, we will see an additional entry, 0x65. Remember that module ID is not the same as loaded module handle. We can now use another of Sony’s custom system calls, number 593, which takes a module handle and a buffer, and fills the buffer with information about the loaded module, including its base address. Since the next available handle is always 0x65, we can hardcode this value into our chain, rather than having to store the result from the module list. The buffer must start with the size of the struct that should be returned, otherwise error 0x16 will be returned, &quot;Invalid argument&quot;: setU64to(moduleInfoAddress, 0x160); chain.syscall(&quot;getModuleInfo&quot;, 593, 0x65, moduleInfoAddress); chain.execute(function() { logAdd(hexDump(moduleInfoAddress, 0x160)); }); It will return 0 upon success, and fill the buffer with a struct which can be read like so: var name = readString(moduleInfoAddress + 0x8); var codeBase = getU64from(moduleInfoAddress + 0x108); var codeSize = getU32from(moduleInfoAddress + 0x110); var dataBase = getU64from(moduleInfoAddress + 0x118); var dataSize = getU32from(moduleInfoAddress + 0x120); We now have everything we need to dump the module! dump(codeBase, codeSize + dataSize); There is another Sony system call, number 608, which works in a similar way to 593, but provides slightly different information about the loaded module: setU64to(moduleInfoAddress, 0x1a8); chain.syscall(&quot;getDifferentModuleInfo&quot;, 608, 0x65, 0, moduleInfoAddress); logAdd(hexDump(moduleInfoAddress, 0x1a8)); It’s not clear what this information is. Browsing the filesystemThe PS4 uses the standard FreeBSD 9.0 system calls for reading files and directories. However, whilst using read for some directories such as /dev/ will work, others, such as / will fail. I’m not sure why this is, but if we use getdents instead of read for directories, it will work much more reliably: writeString(chain.data, &quot;/dev/&quot;); chain.syscall(&quot;open&quot;, 5, chain.data, 0, 0); chain.write_rax_ToVariable(0); chain.read_rdi_FromVariable(0); chain.syscall(&quot;getdents&quot;, 272, undefined, chain.data + 0x10, 1028); This is the resultant memory: 0000010: 0700 0000 1000 0205 6469 7073 7700 0000 ........dipsw... 0000020: 0800 0000 1000 0204 6e75 6c6c 0000 0000 ........null.... 0000030: 0900 0000 1000 0204 7a65 726f 0000 0000 ........zero.... 0000040: 0301 0000 0c00 0402 6664 0000 0b00 0000 ........fd...... 0000050: 1000 0a05 7374 6469 6e00 0000 0d00 0000 ....stdin....... 0000060: 1000 0a06 7374 646f 7574 0000 0f00 0000 ....stdout...... 0000070: 1000 0a06 7374 6465 7272 0000 1000 0000 ....stderr...... 0000080: 1000 0205 646d 656d 3000 0000 1100 0000 ....dmem0....... 0000090: 1000 0205 646d 656d 3100 0000 1300 0000 ....dmem1....... 00000a0: 1000 0206 7261 6e64 6f6d 0000 1400 0000 ....random...... 00000b0: 1000 0a07 7572 616e 646f 6d00 1600 0000 ....urandom..... 00000c0: 1400 020b 6465 6369 5f73 7464 6f75 7400 ....deci_stdout. 00000d0: 1700 0000 1400 020b 6465 6369 5f73 7464 ........deci_std 00000e0: 6572 7200 1800 0000 1400 0209 6465 6369 err.........deci 00000f0: 5f74 7479 3200 0000 1900 0000 1400 0209 _tty2........... 0000100: 6465 6369 5f74 7479 3300 0000 1a00 0000 deci_tty3....... 0000110: 1400 0209 6465 6369 5f74 7479 3400 0000 ....deci_tty4... 0000120: 1b00 0000 1400 0209 6465 6369 5f74 7479 ........deci_tty 0000130: 3500 0000 1c00 0000 1400 0209 6465 6369 5...........deci 0000140: 5f74 7479 3600 0000 1d00 0000 1400 0209 _tty6........... 0000150: 6465 6369 5f74 7479 3700 0000 1e00 0000 deci_tty7....... 0000160: 1400 020a 6465 6369 5f74 7479 6130 0000 ....deci_ttya0.. 0000170: 1f00 0000 1400 020a 6465 6369 5f74 7479 ........deci_tty 0000180: 6230 0000 2000 0000 1400 020a 6465 6369 b0.. .......deci 0000190: 5f74 7479 6330 0000 2200 0000 1400 020a _ttyc0..&quot;....... 00001a0: 6465 6369 5f73 7464 696e 0000 2300 0000 deci_stdin..#... 00001b0: 0c00 0203 6270 6600 2400 0000 1000 0a04 ....bpf.$....... 00001c0: 6270 6630 0000 0000 2900 0000 0c00 0203 bpf0....)....... 00001d0: 6869 6400 2c00 0000 1400 0208 7363 655f hid.,.......sce_ 00001e0: 7a6c 6962 0000 0000 2e00 0000 1000 0204 zlib............ 00001f0: 6374 7479 0000 0000 3400 0000 0c00 0202 ctty....4....... 0000200: 6763 0000 3900 0000 0c00 0203 6463 6500 gc..9.......dce. 0000210: 3a00 0000 1000 0205 6462 6767 6300 0000 :.......dbggc... 0000220: 3e00 0000 0c00 0203 616a 6d00 4100 0000 &gt;.......ajm.A... 0000230: 0c00 0203 7576 6400 4200 0000 0c00 0203 ....uvd.B....... 0000240: 7663 6500 4500 0000 1800 020d 6e6f 7469 vce.E.......noti 0000250: 6669 6361 7469 6f6e 3000 0000 4600 0000 fication0...F... 0000260: 1800 020d 6e6f 7469 6669 6361 7469 6f6e ....notification 0000270: 3100 0000 5000 0000 1000 0206 7573 6263 1...P.......usbc 0000280: 746c 0000 5600 0000 1000 0206 6361 6d65 tl..V.......came 0000290: 7261 0000 8500 0000 0c00 0203 726e 6700 ra..........rng. 00002a0: 0701 0000 0c00 0403 7573 6200 c900 0000 ........usb..... 00002b0: 1000 0a07 7567 656e 302e 3400 0000 0000 ....ugen0.4..... 00002c0: 0000 0000 0000 0000 0000 0000 0000 0000 ................ You can read some of these devices, for example: reading /dev/urandom will fill the memory with random data. It is also possible to parse this memory to create a clean list of entries; look at browser.html in the repository for a complete file browser: Unfortunately, due to sandboxing we don’t have complete access to the file system. Trying to read files and directories that do exist but are restricted will give you error 2, ENOENT, &quot;No such file or directory&quot;. We do have access to a lot of interesting stuff though including encrypted save data, trophies, and account information. I will go over more of the filesystem in my next article. SandboxingAs well as file related system calls failing for certain paths, there are other reasons for a system call to fail. Most commonly, a disallowed system call will just return error 1, EPERM, &quot;Operation not permitted&quot;; such as trying to use ptrace, but other system calls may fail for different reasons: Compatibilty system calls are disabled. If you are trying to call mmap for example, you must use system call number 477, not 71 or 197; otherwise a segfault will be triggered. Other system calls such as exit will also trigger a fault: chain.syscall(&quot;exit&quot;, 1, 0); Trying to create an SCTP socket will return error 0x2b, EPROTONOSUPPORT, indicating that SCTP sockets have been disabled in the PS4 kernel: //int socket(int domain, int type, int protocol); //socket(AF_INET, SOCK_STREAM, IPPROTO_SCTP); chain.syscall(&quot;socket&quot;, 97, 2, 1, 132); And although calling mmap with PROT_READ | PROT_WRITE | PROT_EXEC will return a valid pointer, the PROT_EXEC flag is ignored. Reading its protection will return 3 (RW), and any attempt to execute the memory will trigger a segfault: chain.syscall(&quot;mmap&quot;, 477, 0, 4096, 1 | 2 | 4, 4096, -1, 0); chain.write_rax_ToVariable(0); chain.read_rdi_FromVariable(0); chain.add(&quot;pop rax&quot;, 0xfeeb); chain.add(&quot;mov [rdi], rax&quot;); chain.add(&quot;mov rax, rdi&quot;); chain.add(&quot;jmp rax&quot;); The list of open source software used in the PS4 doesn’t list any kind of sandboxing software like Capsicum, so the PS4 must use either pure FreeBSD jails, or some kind of custom, proprietary, sandboxing system (unlikely). JailsWe can prove the existence of FreeBSD jails being actively used in the PS4’s kernel through the auditon system call being impossible to execute within a jailed environment: chain.syscall(&quot;auditon&quot;, 446, 0, 0, 0); The first thing the auditon system call does is check jailed here, and if so, return ENOSYS: if (jailed(td-&gt;td_ucred)) return (ENOSYS); Otherwise the system call would most likely return EPERM from the mac_system_check_auditon here: error = mac_system_check_auditon(td-&gt;td_ucred, uap-&gt;cmd); if (error) return (error); Or from the priv_check here: error = priv_check(td, PRIV_AUDIT_CONTROL); if (error) return (error); The absolute furthest that the system call could reach would be immediately after the priv_check, here, before returning EINVAL due to the length argument being 0: if ((uap-&gt;length &lt;= 0) || (uap-&gt;length &gt; sizeof(union auditon_udata))) return (EINVAL); Since mac_system_check_auditon and priv_check will never return ENOSYS, having the jailed check pass is the only way ENOSYS could be returned. When executing the chain, ENOSYS _is_ returned (0x48). This tells us that whatever sandbox system the PS4 uses is at least based on jails because the jailed check passes. FreeBSD 9.0 kernel exploitsBefore trying to look for new vulnerabilities in the FreeBSD 9.0 kernel source code, we should first check whether any of the kernel vulnerabilities already found could be used on the PS4. We can immediately dismiss some of these for obvious reasons: FreeBSD 9.0-9.1 mmap/ptrace - Privilege Escalation Exploit - this won’t work since, as previously stated, we don’t have access to the ptrace system call. FreeBSD 9.0 - Intel SYSRET Kernel Privilege Escalation Exploit - won’t work because the PS4 uses an AMD processor. FreeBSD Kernel - Multiple Vulnerabilities - maybe the first vulnerability will lead to something, but the other 2 rely on SCTP sockets, which the PS4 kernel has disabled (as previously stated). However, there are some smaller vulnerabilites, which could lead to something: getloginOne vulnerability which looks easy to try is using the getlogin system call to leak a small amount of kernel memory. The getlogin system call is intended to copy the login name of the current session to userland memory, however, due to a bug, the whole buffer is always copied, and not just the size of the name string. This means that we can read some uninitialised data from the kernel, which might be of some use. Note that the system call (49) is actually int getlogin_r(char *name, int len); and not char *getlogin(void);. So, let’s try copying some kernel memory into an unused part of userland memory: chain.syscall(&quot;getlogin&quot;, 49, chain.data, 17); Unfortunately 17 bytes is the most data we can get, since: Login names are limited to MAXLOGNAME (from &amp;lt;sys/param.h&amp;gt;) characters, currently 17 including null. – FreeBSD Man Pages After executing the chain, the return value was 0, which means that the system call worked! An excellent start. Now let’s take a look at the memory which we pointed to: Before executing the chain: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 After executing the chain: 72 6f 6f 74 00 fe ff ff 08 62 61 82 ff ff ff ff 00 After decoding the first 4 bytes as ASCII: root So the browser is executed as root! That was unexpected. But more interestingly, the memory leaked looks like a pointer to something in the kernel, which is always the same each time the chain is run; this is evidence to support Yifanlu’s claims that the PS4 has no Kernel ASLR! SummaryFrom the information currently available, the PS4’s kernel seems to be very similar to the stock FreeBSD 9.0 kernel. Importantly, the differences that are present appear to be from standard kernel configuration changes (such as disabling SCTP sockets), rather than from modified code. Sony have also added several of their own custom system calls to the kernel, but apart from this, the rest of the kernel seems fairly untouched. In this respect, I’m inclined to believe that the PS4 shares most of the same juicy vulnerabilities as FreeBSD 9.0’s kernel! Unfortunately, most kernel exploits cannot be triggered from the WebKit entry point that we currently have due to sandboxing constraints (likely to be just stock FreeBSD jails). And with FreeBSD 10 being out, it’s unlikely that anyone is stashing away any private exploits for FreeBSD 9, so unless a new one is suddenly released, we’re stuck with what is currently available. The best approach from here seems to be reverse engineering all of the modules which can be dumped, in order to document as many of Sony’s custom system calls as possible; I have a hunch that we will have more luck targeting these, than the standard FreeBSD system calls. Recently Jaicrab has discovered two UART ports on the PS4 which shows us that there are hardware hackers interested in the PS4. Although the role of hardware hackers has traditionally been to dump the RAM of a system, like with the DSi, which we can already do thanks to the WebKit exploit, there’s also the possibility of a hardware triggered kernel vulnerability being found, like geohot’s original PS3 hypervisor hack. It remains most likely that a kernel exploit will be found on the PS4 through system call vulnerabilities though. 原文地址]]></content>
      <categories>
        <category>硬件分析</category>
      </categories>
      <tags>
        <tag>外文翻译</tag>
        <tag>漏洞挖掘</tag>
        <tag>PS4</tag>
        <tag>硬件分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VBA Stomping 简介]]></title>
    <url>%2F2019%2F04%2F30%2FVBA-Stomping%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[原文标题 VBA Stomping — Advanced Maldoc Techniques (Oct 6, 2018) 作者：Kirk Sayre @bigmacjpg，Harold Ogden @haroldogden 和 Carrie Roberts @OrOneEqualsOne VBA Stomping 是一种可以绕过反病毒检测恶意文档生成技术，它最初由 Vesselin Bontchev 博士引起我们的注意（见此处）。VBA stomping 是指销毁 Microsoft Office 文档中的 VBA 源代码，只留下文档文件中称为 p-code 的宏代码的编译版本。在这种情况下，仅基于VBA源代码的恶意文档检测会失败。在这篇博文中，我们将详细演示 VBA stomping 并介绍一些其他技术。 VBA Stomping首先，我们将在一个简单的非恶意宏上演示 VBA Stomping。此文档在打开时显示带有文本 ABC 的消息框。VBA 源代码和生成的消息框如下所示。 现在我们修改上面显示的VBA源代码，同时保持中间 p-code 不变。我们将集中讨论当前的 .docx/.xlsx/.docm/.xlsm（Office 2007 以上）格式。但是，此处讨论的技术可以轻松应用于较旧的 .doc/.xls格式。在 Office 2007 以上文件中，VBA 源代码和 p-code 通常位于名为 vbaProject.bin 的文件中。请注意这是默认文件名，可以被重命名。如果要手动修改此文件，我们需要首先解压 .docm/.xlsm 文件，然后在十六进制编辑器中打开 vbaProject.bin 文件。在此示例中，我们将 ABC 改为 XYZ，但仅限于存储 VBA 源代码的位置，而不是 p-code 部分。VBA 源代码以压缩形式存储，即下图中不可打印或奇怪的字符。 现在我们已经手动编辑了 VBA 源代码将 ABC 更改为 XYZ，我们打开文档并在单击“启用内容”按钮之前检查 VBA 源代码。 我们打开文档但未启用宏。在代码编辑器中检查宏，代码显示宏将显示带有文本 XYZ 的消息框，但事实并非如此。实际上，只要启用了内容，就会显示一个 ABC 的消息框，并且代码编辑器中的源代码会更新以匹配！ 源代码表示 XYZ 将显示在消息框中，但显示 ABC 。到底是怎么回事？ 正如 Bontchev 博士所解释的那样，只要 p-code 与系统上的当前 VBA 版本兼容，文档实际执行的是存储的 p-code。此外，宏编辑器中显示的内容（一旦启用内容）并不是解压的 VBA 源代码，而是反编译的 p-code。 如果我们在不同版本的 Word（使用不同的 VBA 版本）中打开文档，则 p-code 将不可重用。这将强制将 VBA 源代码解压缩并重新编译为 p-code，从而在消息框中显示 XYZ。所以现在我们有一个文档，在一个版本的Office上显示 ABC，但在另一个版本上显示 XYZ。 请注意，这很重要。使用 VBA Stomping 技术的恶意文档只能使用用于创建文档时相同的 VBA 版本执行。 我们可以通过在恶意文档生成之前对目标进行侦察来确定要使用的适当 Office 版本适当 Office 版本；或者通过生成具有多个 Office 版本的恶意文档并将其喷射到目标上来解决此限制。 从防守角度看 VBA stomping 是什么效果呢？通常恶意文档检测仅基于 VBA 源代码。甚至许多可用于分析文档的工具都无法识别 VBA 源和 p-code 之间的差异。由 Philippe Lagadec 编写的 olevba 脚本对篡改文档的分析仅显示了解压缩的源代码，且缺少 p-code 细节。 除非使用 p-code dumper 插件运行，否则 Didier Stevens 的 Python 脚本 oledump.py 也会给出类似的结果。在使用该插件的情况下，输出给出了一些指示，即 p-code 将使消息框显示 ABC，如下图所示。 Bontchev 博士发布了一个名为 pcodedmp.py 的 Python 脚本用于显示 p-code，如下图所示。输出可以显示操作名称而不是上面的操作码。 我们可以通过用零或随机字节覆盖 VBA 源代码来完全擦除（stomp），而不仅仅是修改它。以下截图显示了如何在十六进制编辑器中手动执行此操作。 在这种情况下，VBA 编辑器根本不显示宏代码，但启用内容后仍然显示带有文本 ABC 的消息框。现在，我们在此文件上重新运行 olevba，结果不显示任何VBA源代码，并显示“未找到可疑关键字或 IOC”，而不是之前突出显示我们在使用可疑关键字（AutoOpen）。 这个问题有多严重?我们现在将更深入地了解 Office 如何使用压缩的 VBA 源代码和 p-code。稍后当我们讨论如何滥用 Office 功能来轻松修改恶意文档以欺骗许多 AV 扫描时，这将会发挥作用。 Office 文档包含两个用于提取 VBA 的位置，即压缩的 VBA 源代码和 p-code。下表详细说明了在以下情况下使用哪个 VBA 数据源： 从该表中我们可以看到，如果我们有有效的 p-code，则在启用宏时它会忽略压缩的 VBA 源代码，并通过运行 p-code 来执行所有宏功能。作为攻击者，这告诉我们，我们可以完全破坏或修改压缩的 VBA 源代码，并且仍然让我们的恶意文档执行其指定的任务。 现实案例上述表明这适用于简单示例，但这真的是威胁吗？让我们通过使用已知的恶意文档将其提升到新的水平。在这种情况下，我们将从最近的 Emotet 恶意文档开始，它目前在 Virus total 上被 36/59 的供应商检测为恶意。 如果我们使用这个文档并且如上所述方法简单地处理 VBA 源代码，那么检测率将降至 58 种防病毒解决方案中的 7 种！ 如您所见，这给网络防御者带来了严重的问题。即使手动分析此类文档也可能存在问题。此时显而易见的问题是可以通过工具自动执行 VBA stomping 还是我们必须手动编辑 Office 文档？ 这个问题的答案是肯定的。我们开发了一个 POC 工具来自动在任何 Office 文档中处理压缩的 VBA 源代码（它被用于 VBA stomping 示例的 Emotet 文档，我们不会发布此实用程序）。考虑到自动化 VBA stomping 十分容易，这是一个真正的威胁。 变得更糟考虑恶意文档被设计为在执行恶意有效载荷之后立即关闭 MS Word 的情况。与 VBA stomping 结合使用时，没有脱机的 VBA 源代码提取工具将显示 VBA 源代码，并且在启用宏之前，VBA 源代码甚至不会显示在 Office 宏编辑器窗口中。但是启用宏会导致 Word 立即退出而不提供查看反编译源的机会。虽然我们已经证明“类似汇编”的 p-code 是可提取的，但是 p-code 很难解释，并且无法在 VBA 调试器中被分析。此外 p-code 仅在特定的VBA版本上运行。出于这些原因，访问 VBA 源代码对分析人员来说是一个很大的好处。但是如何才能为这样的文件做到这一点呢？ 经过一些实验，我们找到了一个简单的解决方案，可以在宏启用后立即停止 MS Word 执行任何方法。请注意，此解决方案适用于 Office 2007 以上的文档，我们研究解决较旧的文档格式。Office 2007 以上的解决方案是从 .docm 文件的 word 目录中删除 vbaData.xml 文件，如下所示（这可以通过 7-Zip 程序完成，而无需手动解压缩和重新压缩文档）。 现在我们可以打开文档并启用内容，从而在 VBA 代码编辑器中显示反编译的 p-code，但不执行代码。如果恶意软件作者已采取措施阻止分析人员访问 VBA 源代码，则这种方法可以节省时间。 删除 vbaData.xml 的一个有趣的副作用是它会导致 MS Word 在宏对话框中错误地列出没有宏（参见下图）。 检测我们编写了一个开源工具，用于检测名为 VBA Seismograph 的 Office 文档中的 VBA stomping。此工具已在 Ubuntu 16.04 下测试，它检测声明的函数/变量名称、字符串文字以及出现在已编译的 p-code 和 Office 文档的 VBA 源代码中的注释行之间的差异。该工具可在这里找到。 总结在这篇博客文章中，我们演示了如何修改或销毁 Office 文档中压缩的 VBA 源代码，来绕过 AV 扫描，并使恶意文档的手动分析更加困难。对此技术的防御涉及检测和标记具有有效 p-code 但无效或缺少 VBA 源代码的文档，或更一般地，检查压缩 VBA 源代码与反编译 p-code 之间的差异。目前，我们还没有发现任何进行此项检查的商用 AV 解决方案，因此这是 AV 扫描解决方案可以改进的领域。 参考资料 https://vbastomp.com/ 原文地址]]></content>
      <categories>
        <category>安全技术</category>
      </categories>
      <tags>
        <tag>外文翻译</tag>
        <tag>VBA</tag>
        <tag>安全技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFL 及其相关拓展项目总结]]></title>
    <url>%2F2019%2F04%2F29%2FAFL%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E6%8B%93%E5%B1%95%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[原文标题 Zoo AFL (Apr 24, 2019) 作者：@d1g1 本文主要讨论的不是经典 AFL 本身，而是为其设计的工具以及对其本身做出的改进，我们认为这些改进可以显著提高模糊测试的质量。如果你想知道如何提高 AFL 效率以及如何更快地找到更多漏洞，请继续阅读！ AFL 是什么，它有什么用？AFL是一个覆盖导向或基于反馈的模糊测试工具，关于这些概念的更多信息可以在参考这篇论文 Fuzzing: Art, Science, and Engineering。总结一下 AFL： 它改进可执行文件以了解它如何影响覆盖范围 变异输入数据以最大化覆盖范围 重复上一步以找到程序崩溃的位置 通过实践证明它非常有效 它易于使用 如果你不清楚 AFL 是什么的话，这里有一些资源帮助你上手和理解： 项目主页 AFL 练习 AFL Demo — 使用 AFL fuzz C++ 程序 AFL 发现的漏洞 —（截至 2017） 在这里你可以读到关于 AFL 在构建过程中添加到程序中的内容 一些关于 fuzz 网络程序的技巧 在写这篇文章时 AFL 的最新版本是2.52b。随着时间的推移，一些分支正在被纳入到 AFL 主分支。接下来我们会列举几个有用的附件工具。 关于 Rode0day 竞赛 Rode0day 竞赛每月举办一次，参赛者要在花费更少时间的情况下在预先制作的语料库（无论是否获取源代码）中找到最多的漏洞。就其本质而言，Rode0day 是 AFL 不同分支之间的争斗。 一些AFL用户指出，AFL 的作者 Michal Zalewski 显然已经放弃该项目， 因为上次的改进日期还得追溯到 2017 年 11 月 5 日。这可能与他离开 Google 并开展一些新项目有关。 因此用户开始为最新的版本 2.52b 制作新的补丁)。 AFL 还有不同的变体和衍生物，允许模糊测试 Python，Go，Rust，OCaml，GCJ Java，内核系统调用，甚至整个虚拟机。 AFL 对其它语言的支持 python-afl — Python afl.rs — Rust afl-fuzz-js — Javascript java-afl — Java kelinci — Java（相关文章） javan-warty-pig — JVM afl-swift — Swift ocamlopt-afl — OCaml sharpfuzz — .Net AFL 附属工具本节我们收集了 AFL 的各种脚本和工具，并将它们分为几类： 崩溃处理 afl-utils — 自动处理/分析崩溃和减少测试用例数量 afl-crash-analyzer — AFL 崩溃分析程序 fuzzer-utils — 分析结果 atriage — 简单的分类工具 afl-kit — Python 实现的 afl-cmin AFLize — 生成适合 AFL 的 debian 包的构建 afl-fid — 处理输入数据 代码覆盖率 afl-cov — 提供人性化的覆盖率数据 count-afl-calls — 使用脚本计算二进制文件中的插桩块数，评估其占比 afl-sancov — 类似于 afl-cov 但使用 clang的消毒机制（sanitizer） covnavi — 思科 Talos 开发的用于代码覆盖和分析的脚本 LAF LLVM Passes — 类似于 AFL 的补丁集合，可以改进代码使其更容易找到分支 一些用于最小化测试用例的脚本 afl-pytmin — 一个 afl-tmin 的包装器，它试图通过使用多 CPU 内核来加速最小化测试用例的过程 afl-ddmin-mod — 基于 ddmin 算法的 afl-tmin halfempty — 来自 Tavis Ormandy 基于并行化的快速最小化测试用例的程序 分布式执行 disfuzz-afl — AFL 的分布式模糊测试 AFLDFF — AFL 分布式模糊测试框架 afl-launch — AFL 多实例执行 afl-mothership — AWS 云上多同步 AFL 的管理和执行 afl-in-the-cloud — 另一个在 AWS 中运行 AFL 的脚本 VU_BSc_project — 使用 libFuzzer 和 AFL 对开源库进行模糊测试 最近有一篇文章 Scaling AFL to a 256 thread machine。 部署，管理，监控，报告 afl-other-arch — 用于添加对各种非x86体系结构的支持 afl-trivia — 简化 AFL 管理的脚本 afl-monitor — AFL 监控脚本 afl-manager — Python 实现的用于管理 multi-afl 的 Web 服务器 afl-tools — 带有 afl-latest, afl-dyninst 和 Triforce-afl 的 docker 镜像 afl-remote — 远程管理 AFL 实例的 Web 服务器 包装器（wrapper） phuzzer - 基于 Python 与 AFL 交互 AFL 改进AFL 对漏洞研究人员和模糊测试本身产生了巨大的影响，他们开始根据原始 AFL 进行改进。在不同的情况下，与原始AFL相比，每个改进都有其自身的优缺点。 几乎所有改进版本可以在 hub.docker.com 找到。 目的是什么？ 提高速度并/或提高代码覆盖率 算法 环境 操作系统 硬件 无源码环境 代码模拟 代码插桩 静态 动态 AFL 默认模式在继续研究 AFL 的不同改进和分支之前，我们必须讨论两种重要的模式，这些模式在过去也有过改进但最终被合并。它们是 Syzygy 和 QEMU。 Syzygy 模式 — instrument.exe 中工作的模式1instrument.exe --mode=afl --input-image=test.exe --output-image=test.instr.exe Syzygy 允许使用 AFL 静态重写 PE32 二进制文件，但需要符号和额外环境的才能识别 WinAFL 内核。 QEMU 模式 — QEMU 下的工作方式见 Internals of AFL fuzzer — QEMU Instrumentation使用 QEMU 实现对二进制文件的支持在版本 1.31b 中被添加到 AFL 处理流程上游。AFL QEMU 模式使用 QEMU tcg（一个微小的代码生成器）二进制转换引擎的二进制插桩功能。为此，AFL 有一个 QEMU 的构建脚本，它提取特定版本 QEMU（2.10.0）的源代码，将它们放到几个小的补丁上，并为指定架构构建。然后，创建名为 afl-qemu-trace 的文件，该文件实际上是 QEMU 用户模式模拟（仅可执行ELF文件）的文件。因此，AFL 可以使用不同体系架构（QEMU 支持）中 elf 二进制文件的反馈进行模糊测试。此外，还有许多 AFL 工具，比如从显示器上获取有关当前会话的信息，以及 afl-analyze 等高级内容。但同时 AFL 也会受到 QEMU 的局限， 比如如果工具链使用硬件 SoC 功能构建文件（该功能启动二进制并且 QEMU 不支持），则只要有特定指令或使用特定 MMIO，模糊测试就会中断。 这里是 QEMU 模式的另一个有趣的分支，其中使用TCG代码插桩和缓存，速度提高了3-4倍。 分支AFL 的分支首先与经典 AFL 算法的变化和改进有关。 pe-afl — 对在 Windows 操作系统中没有源代码的 PE 文件进行模糊测试的改进。fuzzer 使用 IDA Pro 分析目标程序，并生成用于接下来静态插桩的信息。然后用 AFL 对插桩后的程序进行模糊测试。 afl-cygwin — 尝试使用 Cygwin 将经典 AFL 移植到Windows。然而它有很多错误且很慢，作者已经放弃了开发 AFLFast（使用 Power Schedule 扩展 AFL） — 最早的 AFL 分支之一。它增加了启发式功能，允许它在短时间内通过更多路径 FairFuzz — AFL 的扩展，针对难抵达的分支 AFLGo — AFL 的扩展，获取代码的某些部分而不是完整的程序覆盖，可用于测试补丁或新添加的代码片段 PerfFuzz — AFL 的扩展，用于查找可能显着减慢程序速度的测试用例 Pythia — AFL 的扩展，预测找到新路径的难度 Angora — 最新的 fuzzer 之一，用 Rust 语言编写，使用新的策略进行变异并增加覆盖范围。 Neuzz — 用神经网络进行模糊测试 UnTracer-AFL — 将 AFl 与 UnTracer 集成以进行有效跟踪 Qsym — 针对混合模糊测试的实用混合执行（concolic execution）引擎。从本质上讲，它是一个符号执行引擎（基本组件作为 intel pin 的插件来实现），它与 AFL 一起执行混合模糊测试。这是基于反馈的模糊测试演变的一个阶段，需要单独讨论。它的主要优点是可以相对快速地进行混合执行。这是由于本机执行命令而没有代码、快照和一些启发式的中间表示。它使用旧版本的Intel pin（由于 libz3 和其他 DBT 之间的支持问题），目前支持ELF x86 和 x86_64 架构 Superion — 灰盒模糊测试器，其优点是除了插桩程序外，它还使用 ANTLR 语法获取输入数据的规范，然后在此语法的帮助下执行变异 AFLSmart — 另一个灰盒模糊测试器，它以 Peach 使用的格式获得输入数据的规范 有许多研究论文致力于实现 AFL 被改进的新方法和模糊测试技术。由于它们只有白皮书，所以我们甚至没有提到这些。如果你愿意，你可以搜索它们。例如最新的一些有 CollAFL: Path Sensitive Fuzzing、EnFuzz、Efficient approach to fuzzing interpreters、ML 用于 AFL 等。 基于 QEMU 的改进 TriforceAFL — AFL/QEMU对系统完全模拟来进行模糊测试。是由 nccgroup 提供的一个分支。它允许在 QEMU 模式下对整个操作系统进行模糊测试。它是通过一个特殊指令（aflCall (0f 24)）（在 QEMU x64 CPU 中添加）实现的。然而它不再受支持; 支持 AFL 的最后一个版本是2.06b TriforceLinuxSyscallFuzzer — Linux 系统调用的模糊测试 afl-qai — 一个带有 QEMU 增强插桩（qai）的小型演示项目。 基于 KLEE 的改进 kleefl — 通过符号执行生成测试用例（在大程序上非常慢） 基于 Unicorn 的改进 afl-unicorn — 允许通过在 Unicorn Engine 上模拟代码片段进行模糊测试 我们在实践中成功使用了 AFL 的这种改进，由于目标是在 SOC 上执行的某个 RTOS（real-time operating system，实时操作系统）的代码区域，因此我们无法使用QEMU模式。在我们没有源代码的情况下（我们无法构建用于解析器分析的独立二进制文件）并且程序不直接获取输入数据（例如，数据被加密或是如在 CGC 二进制文件中的信号样本），然后我们可以逆向并找到所谓的位置函数，函数中中数据以便于模糊测试器使用的格式进行处理。这是 AFL 最普遍/通用的修改，即它允许模糊测试任何东西。它独立于架构、源、输入数据格式和二进制格式（例如裸机，只是来自控制器内存的代码片段）。研究人员首先检查这个二进制文件并编写一个模糊测试器，它在解析过程的输入端模拟状态。显然与 AFL 不同，这需要对二进制进行一定的检查。对于裸机固件，如 Wi-FI 或基带，我们需要记住一些缺点： 我们必须本地处理控制和的检查 模糊测试器的状态是保存在内存转储中的内存状态，这可以防止模糊测试器进入某些路径 动态内存调用没有消毒，但它可以手动实现，它将取决于 RTOS（必须进行研究） 未模拟任务内 RTOS 交互，这也可能阻止寻找某些路径 使用这种修改的例子 afl-unicorn: Fuzzing Arbitrary Binary Code 和 afl-unicorn: Part 2 — Fuzzing the ‘Unfuzzable’。 在我们继续基于动态二进制检测（DBI）框架进行修改之前，不要忘记这些框架的最快速度由 DynamoRIO，Dynlnst 以及 PIN 实现。 基于 PIN 的改进 aflpin — 采用 Intel PIN 插桩的 AFL afl_pin_mode — 另一个采用 Intel PIN 插桩的 AFL afl-pin — 采用 PINtool 的 AFL NaFl — AFL 模糊测试器的克隆（基本核心） PinAFL — 该工具的作者试图将 AFL 移植到 Windows，以便对已编译的二进制文件进行模糊测试。该项目好像是为了好玩而在一夜之间完成的且未进一步发展。存储库里没有源文件，只有已编译的二进制文件和启动指令。我们不知道它基于哪个版本的 AFL，它只支持 32 位应用程序。 正如我们所看到的，AFL 有许多不同的修改，但它们在现实生活中并不是非常有用。 基于 Dyninst 的改进afl-dyninst — AFL + Dyninst == AFL 黑盒模糊测试。这个版本的特点是首先使用 Duninst 对一个研究过的程序（没有源代码）进行静态插桩（静态二进制插桩，静态二进制重写），然后使用经典 AFL 进行模糊测试，AFL 会认为程序是用 afl-gcc/afl-g++/afl-as 构建的。因此，它在没有源代码的情况下以非常好的生产率工作：与本地编译相比，经典 AFL 是 0.25 倍的速度。与QEMU相比，它具有显着优势：它允许动态链接库的插桩，而 QEMU 只能插桩与库静态链接的基本可执行文件。然而现在它只支持 Linux，如果增加对于 Windows 支持，则需要对 Dyninst 本身进行更改，这个工作正在进行中。 还有另一个分支具有提升的速度和某些功能（AARCH64 和 PPC 架构的支持）。 基于 DynamoRIO 的改进 drAFL — AFl + DynamoRIO – 在 Linux 上没有源代码的模糊测试 afl-dr — 基于 DynamoRIO 的另一种实现，在 Habr 上有很好的描述 afl-dynamorio — 来自 vanhauser-thc 的修改。 据他所说：“当正常的 afl-dyninst 能够使二进制崩溃并且 QEMU 模式 -Q 无法执行时，用 DynamoRIO 运行 AFL。”它支持 ARM 和 AARCH64。DynamoRIO 比 QEMU 慢大约 10 倍，比 dyninst 慢 25 倍，但比 Pintool 快 10 倍。 WinAFL — 最著名的 AFL分支。（DynamoRIO，也是 syzygy 模式）。这个修改的出现只是时间问题，因为许多人想在 Windows 上尝试 AFL 并将其应用于没有源代码的应用程序。目前，这个工具正在被积极改进，尽管 AFL 代码库（撰写本文时为 2.43b）相对过时，但它都有助于发现多个漏洞（CVE-2016-7212，CVE-2017-0073，CVE- 2017-0190，CVE-2017-11816）。Google Zero Project 团队和 MSRC 漏洞与解决团队的专家正在参与此项目，因此我们希望它能够得到进一步的发展。开发人员使用动态插桩（基于DynamoRIO）而不是编译时插桩，这显着减慢了被分析软件的执行速度，但产生的开销（加倍）与二进制模式下的经典 AFL 相当。他们还解决了快速启动过程的问题，称其为持续模糊测试模式；他们选择对函数进行模糊测试（通过文件内部的偏移或导出表中存在的函数名称）并对其进行插桩，以便可以在循环中调用它，从而启动多个输入数据样本而无需重新启动程序。最近发表的一篇文章描述了作者如何使用 WinAFL 在约 50 天内发现约 50 个漏洞。发布之后很快 WinAFL 就支持 Intel PT（Processor Tracing，处理器跟踪）模式，在这里可以找到细节信息。 专业读者可能注意到这些改进使用了除了Frida之外的各种流行的插桩框架。 唯一提到 Frida 与 AFL 的结合使用是在 Chizpurfle: A Gray-Box Android Fuzzer for Vendor Service Customizations 中找到的。 带 Frida 的 AFL 版本非常有用，因为 Frida 支持多种 RISC 架构。 许多研究者也期待由 Capstone，Unicorn 和 Keystone 的创建者发布的 DBI Scopio 框架。基于这个框架，作者已经创建了一个模糊测试器（Darko），据他们说能够成功地使用它来对嵌入式设备进行模糊测试。有关这方面的更多信息，请参阅 Digging Deep: Finding 0days in Embedded Systems with Code Coverage Guided Fuzzing。 基于处理器硬件特征的改进关于支持处理器硬件功能的 AFL 修改方面，首先，它允许对内核代码进行模糊测试；其次，它允许在没有源代码的情况下更快地对应用程序进行模糊测试。 当然，谈到处理器硬件功能，我们最感兴趣的是 Intel PT。从第 6 代处理器开始（大约自2015年起）支持该功能。 因此，为了能够使用下面列出的模糊测试器，我们需要一个支持 Intel PT 的处理器。 WinAFL-IntelPT — 使用 Intel PT 而不是 DynamoRIO 的第三方 WinAFL。 ptfuzzer - 使用 Intel PT 对二进制进行黑盒测试。 kAFL — 一个旨在解决独立于操作系统的模糊测试内核时的覆盖率导向问题的学术项目。 它通过使用管理程序（hypervisor）和 Intel PT 来解决该问题。有关它的更多信息可以在白皮书 kAFL: Hardware-Assisted Feedback Fuzzing for OS Kernels 中找到。 总结如你所见，研究人员仍在积极地改进 AFL，而且 AFL 还存在进行实验和创新的空间，我们也可以创建一个我们自己的实用有趣的 AFL。 感谢阅读，祝大家 Fuzz 顺利。 原文链接]]></content>
      <categories>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>外文翻译</tag>
        <tag>漏洞挖掘</tag>
        <tag>AFL</tag>
      </tags>
  </entry>
</search>
