<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zanderchang.github.io/"/>
  <updated>2019-04-30T04:05:06.882Z</updated>
  <id>http://zanderchang.github.io/</id>
  
  <author>
    <name>Glory</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VBA Stomping简介</title>
    <link href="http://zanderchang.github.io/2019/04/30/VBA-Stomping%E7%AE%80%E4%BB%8B/"/>
    <id>http://zanderchang.github.io/2019/04/30/VBA-Stomping简介/</id>
    <published>2019-04-30T02:17:09.000Z</published>
    <updated>2019-04-30T04:05:06.882Z</updated>
    
    <content type="html"><![CDATA[<p><em>原文标题 VBA Stomping — Advanced Maldoc Techniques (Oct 6, 2018)</em></p><p>作者：Kirk Sayre <a href="https://twitter.com/bigmacjpg" target="_blank" rel="noopener">@bigmacjpg</a>，Harold Ogden <a href="https://twitter.com/haroldogden" target="_blank" rel="noopener">@haroldogden</a> 和 Carrie Roberts <a href="https://twitter.com/OrOneEqualsOne" target="_blank" rel="noopener">@OrOneEqualsOne</a></p><p>VBA Stomping 是一种可以绕过反病毒检测恶意文档生成技术，它最初由 Vesselin Bontchev 博士引起我们的注意（见<a href="https://github.com/bontchev/pcodedmp" target="_blank" rel="noopener">此处</a>）。VBA stomping 是指销毁 Microsoft Office 文档中的 VBA 源代码，只留下文档文件中称为 p-code 的宏代码的编译版本。在这种情况下，仅基于VBA源代码的恶意文档检测会失败。在这篇博文中，我们将详细演示 VBA stomping 并介绍一些其他技术。</p><a id="more"></a><h2 id="VBA-Stomping"><a href="#VBA-Stomping" class="headerlink" title="VBA Stomping"></a>VBA Stomping</h2><p>首先，我们将在一个简单的非恶意宏上演示 VBA Stomping。此文档在打开时显示带有文本 ABC 的消息框。VBA 源代码和生成的消息框如下所示。</p><p><img src="/img/vba-stomping/1_P_mM0Ffo9kzzhtMM1O7oCg.png" alt></p><p>现在我们修改上面显示的VBA源代码，同时保持中间 p-code 不变。我们将集中讨论当前的 .docx/.xlsx/.docm/.xlsm（Office 2007 以上）格式。但是，此处讨论的技术可以轻松应用于较旧的 .doc/.xls格式。在 Office 2007 以上文件中，VBA 源代码和 p-code 通常位于名为 vbaProject.bin 的文件中。请注意这是默认文件名，可以被重命名。如果要手动修改此文件，我们需要首先解压 .docm/.xlsm 文件，然后在十六进制编辑器中打开 vbaProject.bin 文件。在此示例中，我们将 ABC 改为 XYZ，但仅限于存储 VBA 源代码的位置，而不是 p-code 部分。VBA 源代码以压缩形式存储，即下图中不可打印或奇怪的字符。</p><p><img src="/img/vba-stomping/1_KGc1XphbyNT5Dws5W8lOPQ.png" alt></p><p><img src="/img/vba-stomping/1_iHWUB-LOeGuw_8K02Gixpg.png" alt></p><p>现在我们已经手动编辑了 VBA 源代码将 ABC 更改为 XYZ，我们打开文档并在单击“启用内容”按钮之前检查 VBA 源代码。</p><p><img src="/img/vba-stomping/1_jqYto7TMBR3MUZPqzdhogw.png" alt></p><p>我们打开文档但未启用宏。在代码编辑器中检查宏，代码显示宏将显示带有文本 XYZ 的消息框，但事实并非如此。实际上，只要启用了内容，就会显示一个 ABC 的消息框，并且代码编辑器中的源代码会更新以匹配！</p><p><img src="/img/vba-stomping/1_VE19x2i45U7r6FXDxov1UA.png" alt></p><p>源代码表示 XYZ 将显示在消息框中，但显示 ABC 。到底是怎么回事？</p><p>正如 Bontchev 博士所解释的那样，只要 p-code 与系统上的当前 VBA 版本兼容，文档实际执行的是存储的 p-code。此外，宏编辑器中显示的内容（一旦启用内容）并不是解压的 VBA 源代码，而是反编译的 p-code。</p><p>如果我们在不同版本的 Word（使用不同的 VBA 版本）中打开文档，则 p-code 将不可重用。这将强制将 VBA 源代码解压缩并重新编译为 p-code，从而在消息框中显示 XYZ。所以现在我们有一个文档，在一个版本的Office上显示 ABC，但在另一个版本上显示 XYZ。</p><p>请注意，这很重要。<strong>使用 VBA Stomping 技术的恶意文档只能使用用于创建文档时相同的 VBA 版本执行。</strong> 我们可以通过在恶意文档生成之前对目标进行侦察来确定要使用的适当 Office 版本适当 Office 版本；或者通过生成具有多个 Office 版本的恶意文档并将其喷射到目标上来解决此限制。</p><p>从防守角度看 VBA stomping 是什么效果呢？通常恶意文档检测仅基于 VBA 源代码。甚至许多可用于分析文档的工具都无法识别 VBA 源和 p-code 之间的差异。由 Philippe Lagadec 编写的 <a href="https://github.com/decalage2/oletools/wiki/olevba" target="_blank" rel="noopener">olevba 脚本</a>对篡改文档的分析仅显示了解压缩的源代码，且缺少 p-code 细节。</p><p><img src="/img/vba-stomping/1_TIq1-TyPn5gxopcr88-U9A.png" alt></p><p>除非使用 p-code dumper 插件运行，否则 Didier Stevens 的 Python 脚本 <a href="https://blog.didierstevens.com/programs/oledump-py/" target="_blank" rel="noopener">oledump.py</a> 也会给出类似的结果。在使用该插件的情况下，输出给出了一些指示，即 p-code 将使消息框显示 ABC，如下图所示。</p><p><img src="/img/vba-stomping/1_ZmBHbwFxuqbZB9JZzN4yrw.png" alt></p><p>Bontchev 博士发布了一个名为 <a href="https://github.com/bontchev/pcodedmp" target="_blank" rel="noopener">pcodedmp.py</a> 的 Python 脚本用于显示 p-code，如下图所示。输出可以显示操作名称而不是上面的操作码。</p><p><img src="/img/vba-stomping/1_1jU7iSKRyTb93EK5WfIZ3Q.png" alt></p><p>我们可以通过用零或随机字节覆盖 VBA 源代码来完全擦除（stomp），而不仅仅是修改它。以下截图显示了如何在十六进制编辑器中手动执行此操作。</p><p><img src="/img/vba-stomping/1_xCsSmTV9k0qFMjUWfQDWuQ.png" alt></p><p><img src="/img/vba-stomping/1_XLiGHjipu6lk7JU8rNxzXw.png" alt></p><p>在这种情况下，VBA 编辑器根本不显示宏代码，但启用内容后仍然显示带有文本 ABC 的消息框。现在，我们在此文件上重新运行 olevba，结果不显示任何VBA源代码，并显示“未找到可疑关键字或 IOC”，而不是之前突出显示我们在使用可疑关键字（AutoOpen）。</p><p><img src="/img/vba-stomping/1_3t0jKe01yE0ydhE2pFXvxA.png" alt></p><h1 id="这个问题有多严重"><a href="#这个问题有多严重" class="headerlink" title="这个问题有多严重?"></a>这个问题有多严重?</h1><p>我们现在将更深入地了解 Office 如何使用压缩的 VBA 源代码和 p-code。稍后当我们讨论如何滥用 Office 功能来轻松修改恶意文档以欺骗许多 AV 扫描时，这将会发挥作用。</p><p>Office 文档包含两个用于提取 VBA 的位置，即压缩的 VBA 源代码和 p-code。下表详细说明了在以下情况下使用哪个 VBA 数据源：</p><p><img src="/img/vba-stomping/1_Eh5SA794dEMFOlkqR8ThDQ.png" alt></p><p>从该表中我们可以看到，如果我们有有效的 p-code，则在启用宏时它会忽略压缩的 VBA 源代码，并通过运行 p-code 来执行所有宏功能。作为攻击者，这告诉我们，我们可以完全破坏或修改压缩的 VBA 源代码，并且仍然让我们的恶意文档执行其指定的任务。</p><h1 id="现实案例"><a href="#现实案例" class="headerlink" title="现实案例"></a>现实案例</h1><p>上述表明这适用于简单示例，但这真的是威胁吗？让我们通过使用已知的恶意文档将其提升到新的水平。在这种情况下，我们将从最近的 <a href="https://www.cyber.nj.gov/threat-profiles/trojan-variants/emotet" target="_blank" rel="noopener">Emotet</a> 恶意文档开始，它目前在 Virus total 上被 36/59 的供应商检测为恶意。</p><p><img src="/img/vba-stomping/1_vhePAlQl6xO7TLdXXW1mCg.png" alt></p><p>如果我们使用这个文档并且如上所述方法简单地处理 VBA 源代码，那么检测率将降至 58 种防病毒解决方案中的 7 种！</p><p><img src="/img/vba-stomping/1_15XLHrfFRP4PcFoTSX1GCA.png" alt></p><p>如您所见，这给网络防御者带来了严重的问题。即使手动分析此类文档也可能存在问题。此时显而易见的问题是<em>可以通过工具自动执行 VBA stomping 还是我们必须手动编辑 Office 文档？</em> 这个问题的答案是肯定的。我们开发了一个 POC 工具来自动在任何 Office 文档中处理压缩的 VBA 源代码（它被用于 VBA stomping 示例的 Emotet 文档，我们不会发布此实用程序）。考虑到自动化 VBA stomping 十分容易，这是一个真正的威胁。</p><h1 id="变得更糟"><a href="#变得更糟" class="headerlink" title="变得更糟"></a>变得更糟</h1><p>考虑恶意文档被设计为在执行恶意有效载荷之后立即关闭 MS Word 的情况。与 VBA stomping 结合使用时，没有脱机的 VBA 源代码提取工具将显示 VBA 源代码，并且在启用宏之前，VBA 源代码甚至不会显示在 Office 宏编辑器窗口中。但是启用宏会导致 Word 立即退出而不提供查看反编译源的机会。虽然我们已经证明“类似汇编”的 p-code 是可提取的，但是 p-code 很难解释，并且无法在 VBA 调试器中被分析。此外 p-code 仅在特定的VBA版本上运行。出于这些原因，访问 VBA 源代码对分析人员来说是一个很大的好处。但是如何才能为这样的文件做到这一点呢？</p><p>经过一些实验，我们找到了一个简单的解决方案，可以在宏启用后立即停止 MS Word 执行任何方法。请注意，此解决方案适用于 Office 2007 以上的文档，我们研究解决较旧的文档格式。Office 2007 以上的解决方案是从 .docm 文件的 word 目录中删除 vbaData.xml 文件，如下所示（这可以通过 7-Zip 程序完成，而无需手动解压缩和重新压缩文档）。</p><p><img src="/img/vba-stomping/1_j953lLi4vkji5nySs3YPeg.png" alt></p><p>现在我们可以打开文档并启用内容，从而在 VBA 代码编辑器中显示反编译的 p-code，但不执行代码。如果恶意软件作者已采取措施阻止分析人员访问 VBA 源代码，则这种方法可以节省时间。</p><p>删除 vbaData.xml 的一个有趣的副作用是它会导致 MS Word 在宏对话框中错误地列出没有宏（参见下图）。</p><p><img src="/img/vba-stomping/1_KIhYa2asfDGRAIWXERhXug.png" alt></p><h1 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h1><p>我们编写了一个开源工具，用于检测名为 VBA Seismograph 的 Office 文档中的 VBA stomping。此工具已在 Ubuntu 16.04 下测试，它检测声明的函数/变量名称、字符串文字以及出现在已编译的 p-code 和 Office 文档的 VBA 源代码中的注释行之间的差异。该工具可在<a href="https://github.com/kirk-sayre-work/VBASeismograph" target="_blank" rel="noopener">这里</a>找到。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在这篇博客文章中，我们演示了如何修改或销毁 Office 文档中压缩的 VBA 源代码，来绕过 AV 扫描，并使恶意文档的手动分析更加困难。对此技术的防御涉及检测和标记具有有效 p-code 但无效或缺少 VBA 源代码的文档，或更一般地，检查压缩 VBA 源代码与反编译 p-code 之间的差异。目前，我们还没有发现任何进行此项检查的商用 AV 解决方案，因此这是 AV 扫描解决方案可以改进的领域。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://vbastomp.com/" target="_blank" rel="noopener">https://vbastomp.com/</a></li></ul><p><a href="https://medium.com/walmartlabs/vba-stomping-advanced-maldoc-techniques-612c484ab278" target="_blank" rel="noopener">原文地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;原文标题 VBA Stomping — Advanced Maldoc Techniques (Oct 6, 2018)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;作者：Kirk Sayre &lt;a href=&quot;https://twitter.com/bigmacjpg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@bigmacjpg&lt;/a&gt;，Harold Ogden &lt;a href=&quot;https://twitter.com/haroldogden&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@haroldogden&lt;/a&gt; 和 Carrie Roberts &lt;a href=&quot;https://twitter.com/OrOneEqualsOne&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@OrOneEqualsOne&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;VBA Stomping 是一种可以绕过反病毒检测恶意文档生成技术，它最初由 Vesselin Bontchev 博士引起我们的注意（见&lt;a href=&quot;https://github.com/bontchev/pcodedmp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;此处&lt;/a&gt;）。VBA stomping 是指销毁 Microsoft Office 文档中的 VBA 源代码，只留下文档文件中称为 p-code 的宏代码的编译版本。在这种情况下，仅基于VBA源代码的恶意文档检测会失败。在这篇博文中，我们将详细演示 VBA stomping 并介绍一些其他技术。&lt;/p&gt;
    
    </summary>
    
      <category term="安全技术" scheme="http://zanderchang.github.io/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="外文翻译" scheme="http://zanderchang.github.io/tags/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
      <category term="VBA" scheme="http://zanderchang.github.io/tags/VBA/"/>
    
      <category term="安全技术" scheme="http://zanderchang.github.io/tags/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>AFL及其相关拓展项目总结</title>
    <link href="http://zanderchang.github.io/2019/04/29/AFL%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E6%8B%93%E5%B1%95%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://zanderchang.github.io/2019/04/29/AFL及其相关拓展项目总结/</id>
    <published>2019-04-29T06:44:42.000Z</published>
    <updated>2019-05-06T02:31:01.775Z</updated>
    
    <content type="html"><![CDATA[<p><em>原文标题 Zoo AFL (Apr 24, 2019)</em></p><p>作者：<a href="https://habr.com/en/users/d1g1/" target="_blank" rel="noopener">@d1g1</a></p><p>本文主要讨论的不是经典 AFL 本身，而是为其设计的工具以及对其本身做出的改进，我们认为这些改进可以显著提高模糊测试的质量。如果你想知道如何提高 AFL 效率以及如何更快地找到更多漏洞，请继续阅读！</p><a id="more"></a><h1 id="AFL-是什么，它有什么用？"><a href="#AFL-是什么，它有什么用？" class="headerlink" title="AFL 是什么，它有什么用？"></a>AFL 是什么，它有什么用？</h1><p>AFL是一个覆盖导向或基于反馈的模糊测试工具，关于这些概念的更多信息可以在参考这篇论文 <a href="https://arxiv.org/abs/1812.00140" target="_blank" rel="noopener">Fuzzing: Art, Science, and Engineering</a>。总结一下 AFL：</p><ul><li>它改进可执行文件以了解它如何影响覆盖范围</li><li>变异输入数据以最大化覆盖范围</li><li>重复上一步以找到程序崩溃的位置</li><li>通过实践证明它非常有效</li><li>它易于使用</li></ul><p>如果你不清楚 AFL 是什么的话，这里有一些资源帮助你上手和理解：</p><ul><li><a href="http://lcamtuf.coredump.cx/afl/" target="_blank" rel="noopener">项目主页</a></li><li><a href="https://github.com/ThalesIgnite/afl-training" target="_blank" rel="noopener">AFL 练习</a></li><li><a href="https://gitlab.com/wolframroesler/afl-demo" target="_blank" rel="noopener">AFL Demo</a> — 使用 AFL fuzz C++ 程序</li><li><a href="https://github.com/mrash/afl-cve" target="_blank" rel="noopener">AFL 发现的漏洞</a> —（截至 2017）</li><li>在<a href="https://tunnelshade.in/blog/2018/01/afl-internals-compile-time-instrumentation/" target="_blank" rel="noopener">这里</a>你可以读到关于 AFL 在构建过程中添加到程序中的内容</li><li><a href="https://copyninja.info/blog/afl-and-network-programs.html" target="_blank" rel="noopener">一些</a>关于 fuzz 网络程序的技巧</li></ul><p>在写这篇文章时 AFL 的最新版本是<a href="http://lcamtuf.coredump.cx/afl/" target="_blank" rel="noopener">2.52b</a>。随着时间的推移，一些分支正在被纳入到 AFL 主分支。接下来我们会列举几个有用的附件工具。</p><p><strong>关于 Rode0day 竞赛</strong></p><p><a href="https://rode0day.mit.edu/" target="_blank" rel="noopener">Rode0day</a> 竞赛每月举办一次，参赛者要在花费更少时间的情况下在预先制作的语料库（无论是否获取源代码）中找到最多的漏洞。就其本质而言，Rode0day 是 AFL 不同分支之间的争斗。</p><p>一些AFL用户<a href="https://groups.google.com/forum/#!topic/afl-users/6NTPAkK7JEk" target="_blank" rel="noopener">指出</a>，AFL 的作者 Michal Zalewski 显然已经放弃该项目， 因为上次的改进日期还得追溯到 2017 年 11 月 5 日。这可能与他离开 Google 并开展一些新项目有关。 因此用户开始为最新的版本 2.52b 制作新的<a href="https://github.com/vanhauser-thc/afl-patches" target="_blank" rel="noopener">补丁</a>)。</p><p>AFL 还有不同的变体和衍生物，允许模糊测试 Python，Go，Rust，OCaml，GCJ Java，内核系统调用，甚至整个虚拟机。</p><p><strong>AFL 对其它语言的支持</strong></p><ul><li><a href="https://github.com/jwilk/python-afl" target="_blank" rel="noopener">python-afl</a> — Python</li><li><a href="https://github.com/rust-fuzz/afl.rs" target="_blank" rel="noopener">afl.rs</a> — Rust</li><li><a href="https://github.com/connor4312/js-fuzz" target="_blank" rel="noopener">afl-fuzz-js</a> — Javascript</li><li><a href="https://github.com/Barro/java-afl" target="_blank" rel="noopener">java-afl</a> — Java</li><li><a href="https://github.com/isstac/kelinci" target="_blank" rel="noopener">kelinci</a> — Java（<a href="https://www.modzero.ch/modlog/archives/2018/09/20/java_bugs_with_and_without_fuzzing/index.html" target="_blank" rel="noopener">相关文章</a>）</li><li><a href="https://github.com/cretz/javan-warty-pig" target="_blank" rel="noopener">javan-warty-pig</a> — JVM</li><li><a href="https://github.com/Proteas/afl-swift" target="_blank" rel="noopener">afl-swift</a> — Swift</li><li><a href="https://github.com/kayceesrk/ocamlopt-afl" target="_blank" rel="noopener">ocamlopt-afl</a> — OCaml</li><li><a href="https://github.com/Metalnem/sharpfuzz" target="_blank" rel="noopener">sharpfuzz</a> — .Net</li></ul><h1 id="AFL-附属工具"><a href="#AFL-附属工具" class="headerlink" title="AFL 附属工具"></a>AFL 附属工具</h1><p>本节我们收集了 AFL 的各种脚本和工具，并将它们分为几类：</p><h2 id="崩溃处理"><a href="#崩溃处理" class="headerlink" title="崩溃处理"></a>崩溃处理</h2><ul><li><a href="https://gitlab.com/rc0r/afl-utils" target="_blank" rel="noopener">afl-utils</a> — 自动处理/分析崩溃和减少测试用例数量</li><li><a href="https://github.com/floyd-fuh/afl-crash-analyzer" target="_blank" rel="noopener">afl-crash-analyzer</a> — AFL 崩溃分析程序</li><li><a href="https://github.com/ThePatrickStar/fuzzer-utils" target="_blank" rel="noopener">fuzzer-utils</a> — 分析结果</li><li><a href="https://github.com/Ayrx/atriage" target="_blank" rel="noopener">atriage</a> — 简单的分类工具</li><li><a href="https://github.com/kcwu/afl-kit" target="_blank" rel="noopener">afl-kit</a> — Python 实现的 afl-cmin</li><li><a href="https://github.com/d33tah/aflize" target="_blank" rel="noopener">AFLize</a> — 生成适合 AFL 的 debian 包的构建</li><li><a href="https://github.com/FoRTE-Research/afl-fid" target="_blank" rel="noopener">afl-fid</a> — 处理输入数据</li></ul><h2 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h2><ul><li><a href="https://github.com/mrash/afl-cov" target="_blank" rel="noopener">afl-cov</a> — 提供人性化的覆盖率数据</li><li><a href="https://github.com/Barro/count-afl-calls" target="_blank" rel="noopener">count-afl-calls</a> — 使用脚本计算二进制文件中的插桩块数，评估其占比</li><li><a href="https://github.com/bshastry/afl-sancov" target="_blank" rel="noopener">afl-sancov</a> — 类似于 afl-cov 但使用 clang的消毒机制（sanitizer）</li><li><a href="https://github.com/Cisco-Talos/covnavi" target="_blank" rel="noopener">covnavi</a> — 思科 Talos 开发的用于代码覆盖和分析的脚本</li><li><a href="https://gitlab.com/laf-intel/laf-llvm-pass/tree/master" target="_blank" rel="noopener">LAF LLVM Passes</a> — 类似于 AFL 的补丁集合，可以改进代码使其更容易找到分支</li></ul><h2 id="一些用于最小化测试用例的脚本"><a href="#一些用于最小化测试用例的脚本" class="headerlink" title="一些用于最小化测试用例的脚本"></a>一些用于最小化测试用例的脚本</h2><ul><li><a href="https://github.com/ilsani/afl-pytmin" target="_blank" rel="noopener">afl-pytmin</a> — 一个 afl-tmin 的包装器，它试图通过使用多 CPU 内核来加速最小化测试用例的过程</li><li><a href="https://github.com/MarkusTeufelberger/afl-ddmin-mod" target="_blank" rel="noopener">afl-ddmin-mod</a> — 基于 ddmin 算法的 afl-tmin</li><li><a href="https://github.com/googleprojectzero/halfempty" target="_blank" rel="noopener">halfempty</a> — 来自 Tavis Ormandy 基于并行化的快速最小化测试用例的程序</li></ul><h2 id="分布式执行"><a href="#分布式执行" class="headerlink" title="分布式执行"></a>分布式执行</h2><ul><li><a href="https://github.com/MartijnB/disfuzz-afl" target="_blank" rel="noopener">disfuzz-afl</a> — AFL 的分布式模糊测试</li><li><a href="https://github.com/quantumvm/AFLDFF" target="_blank" rel="noopener">AFLDFF</a> — AFL 分布式模糊测试框架</li><li><a href="https://github.com/bnagy/afl-launch" target="_blank" rel="noopener">afl-launch</a> — AFL 多实例执行</li><li><a href="https://github.com/afl-mothership/afl-mothership" target="_blank" rel="noopener">afl-mothership</a> — AWS 云上多同步 AFL 的管理和执行</li><li><a href="https://github.com/abhisek/afl-in-the-cloud" target="_blank" rel="noopener">afl-in-the-cloud</a> — 另一个在 AWS 中运行 AFL 的脚本</li><li><a href="https://github.com/clvang000/VU_BSc_project" target="_blank" rel="noopener">VU_BSc_project</a> — 使用 libFuzzer 和 AFL 对开源库进行模糊测试</li></ul><p>最近有一篇文章 <a href="https://gamozolabs.github.io/fuzzing/2018/09/16/scaling_afl.html" target="_blank" rel="noopener">Scaling AFL to a 256 thread machine</a>。</p><h2 id="部署，管理，监控，报告"><a href="#部署，管理，监控，报告" class="headerlink" title="部署，管理，监控，报告"></a>部署，管理，监控，报告</h2><ul><li><a href="https://github.com/shellphish/afl-other-arch" target="_blank" rel="noopener">afl-other-arch</a> — 用于添加对各种非x86体系结构的支持</li><li><a href="https://github.com/bnagy/afl-trivia" target="_blank" rel="noopener">afl-trivia</a> — 简化 AFL 管理的脚本</li><li><a href="https://github.com/reflare/afl-monitor" target="_blank" rel="noopener">afl-monitor</a> — AFL 监控脚本</li><li><a href="https://github.com/zx1340/afl-manager" target="_blank" rel="noopener">afl-manager</a> — Python 实现的用于管理 multi-afl 的 Web 服务器</li><li><a href="https://hub.docker.com/r/moflow/afl-tools/" target="_blank" rel="noopener">afl-tools</a> — 带有 afl-latest, afl-dyninst 和 Triforce-afl 的 docker 镜像</li><li><a href="https://github.com/block8437/afl-remote" target="_blank" rel="noopener">afl-remote</a> — 远程管理 AFL 实例的 Web 服务器</li></ul><h2 id="包装器（wrapper）"><a href="#包装器（wrapper）" class="headerlink" title="包装器（wrapper）"></a>包装器（wrapper）</h2><ul><li><a href="https://github.com/angr/phuzzer" target="_blank" rel="noopener">phuzzer</a> - 基于 Python 与 AFL 交互</li></ul><h1 id="AFL-改进"><a href="#AFL-改进" class="headerlink" title="AFL 改进"></a>AFL 改进</h1><p>AFL 对漏洞研究人员和模糊测试本身产生了巨大的影响，他们开始根据原始 AFL 进行改进。在不同的情况下，与原始AFL相比，每个改进都有其自身的优缺点。</p><p>几乎所有改进版本可以在 <a href="https://hub.docker.com" target="_blank" rel="noopener">hub.docker.com</a> 找到。</p><p>目的是什么？</p><ul><li><p>提高速度并/或提高代码覆盖率</p><ul><li>算法</li><li>环境<ul><li>操作系统</li><li>硬件</li></ul></li></ul></li><li><p>无源码环境</p><ul><li>代码模拟</li><li>代码插桩<ul><li>静态</li><li>动态</li></ul></li></ul></li></ul><h2 id="AFL-默认模式"><a href="#AFL-默认模式" class="headerlink" title="AFL 默认模式"></a>AFL 默认模式</h2><p>在继续研究 AFL 的不同改进和分支之前，我们必须讨论两种重要的模式，这些模式在过去也有过改进但最终被合并。它们是 Syzygy 和 QEMU。</p><h3 id="Syzygy-模式-—-instrument-exe-中工作的模式"><a href="#Syzygy-模式-—-instrument-exe-中工作的模式" class="headerlink" title="Syzygy 模式 — instrument.exe 中工作的模式"></a><a href="https://doar-e.github.io/blog/2017/08/05/binary-rewriting-with-syzygy/" target="_blank" rel="noopener">Syzygy</a> 模式 — instrument.exe 中工作的模式</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instrument<span class="selector-class">.exe</span> --mode=afl --input-image=test<span class="selector-class">.exe</span> --output-image=test<span class="selector-class">.instr</span><span class="selector-class">.exe</span></span><br></pre></td></tr></table></figure><p>Syzygy 允许使用 AFL 静态重写 PE32 二进制文件，但需要符号和额外环境的才能识别 WinAFL 内核。</p><h3 id="QEMU-模式-—-QEMU-下的工作方式见-Internals-of-AFL-fuzzer-—-QEMU-Instrumentation"><a href="#QEMU-模式-—-QEMU-下的工作方式见-Internals-of-AFL-fuzzer-—-QEMU-Instrumentation" class="headerlink" title="QEMU 模式 — QEMU 下的工作方式见 Internals of AFL fuzzer — QEMU Instrumentation"></a>QEMU 模式 — QEMU 下的工作方式见 <a href="https://tunnelshade.in/blog/2018/02/afl-internals-qemu-instrumentation/" target="_blank" rel="noopener">Internals of AFL fuzzer — QEMU Instrumentation</a></h3><p>使用 QEMU 实现对二进制文件的支持在版本 1.31b 中被添加到 AFL 处理流程上游。AFL QEMU 模式使用 QEMU tcg（一个微小的代码生成器）二进制转换引擎的二进制插桩功能。为此，AFL 有一个 QEMU 的构建脚本，它提取特定版本 QEMU（2.10.0）的源代码，将它们放到几个小的补丁上，并为指定架构构建。然后，创建名为 afl-qemu-trace 的文件，该文件实际上是 QEMU 用户模式模拟（仅可执行ELF文件）的文件。因此，AFL 可以使用不同体系架构（QEMU 支持）中 elf 二进制文件的反馈进行模糊测试。此外，还有许多 AFL 工具，比如从显示器上获取有关当前会话的信息，以及 afl-analyze 等高级内容。但同时 AFL 也会受到 QEMU 的局限， 比如如果工具链使用硬件 SoC 功能构建文件（该功能启动二进制并且 QEMU 不支持），则只要有特定指令或使用特定 MMIO，模糊测试就会中断。</p><p><a href="https://abiondo.me/2018/09/21/improving-afl-qemu-mode/" target="_blank" rel="noopener">这里</a>是 QEMU 模式的另一个有趣的分支，其中使用TCG代码插桩和缓存，速度提高了3-4倍。</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>AFL 的分支首先与经典 AFL 算法的变化和改进有关。</p><ul><li><a href="https://github.com/wmliang/pe-afl" target="_blank" rel="noopener">pe-afl</a> — 对在 Windows 操作系统中没有源代码的 PE 文件进行模糊测试的改进。fuzzer 使用 IDA Pro 分析目标程序，并生成用于接下来静态插桩的信息。然后用 AFL 对插桩后的程序进行模糊测试。</li><li><a href="https://github.com/arizvisa/afl-cygwin" target="_blank" rel="noopener">afl-cygwin</a> — 尝试使用 Cygwin 将经典 AFL 移植到Windows。然而它有很多错误且很慢，作者已经放弃了开发</li><li><a href="https://github.com/mboehme/aflfast" target="_blank" rel="noopener">AFLFast</a>（使用 Power Schedule 扩展 AFL） — 最早的 AFL 分支之一。它增加了启发式功能，允许它在短时间内通过更多路径</li><li><a href="https://github.com/carolemieux/afl-rb" target="_blank" rel="noopener">FairFuzz</a> — AFL 的扩展，针对难抵达的分支</li><li><a href="https://github.com/aflgo/aflgo" target="_blank" rel="noopener">AFLGo</a> — AFL 的扩展，获取代码的某些部分而不是完整的程序覆盖，可用于测试补丁或新添加的代码片段</li><li><a href="https://github.com/carolemieux/perffuzz" target="_blank" rel="noopener">PerfFuzz</a> — AFL 的扩展，用于查找可能显着减慢程序速度的测试用例</li><li><a href="https://github.com/mboehme/pythia" target="_blank" rel="noopener">Pythia</a> — AFL 的扩展，预测找到新路径的难度</li><li><a href="https://github.com/AngoraFuzzer/Angora" target="_blank" rel="noopener">Angora</a> — 最新的 fuzzer 之一，用 Rust 语言编写，使用新的策略进行变异并增加覆盖范围。</li><li><a href="https://github.com/Dongdongshe/neuzz" target="_blank" rel="noopener">Neuzz</a> — 用神经网络进行模糊测试</li><li><a href="https://github.com/FoRTE-Research/UnTracer-AFL" target="_blank" rel="noopener">UnTracer-AFL</a> — 将 AFl 与 UnTracer 集成以进行有效跟踪</li><li><a href="https://github.com/sslab-gatech/qsym/" target="_blank" rel="noopener">Qsym</a> — 针对混合模糊测试的实用混合执行（concolic execution）引擎。从本质上讲，它是一个符号执行引擎（基本组件作为 intel pin 的插件来实现），它与 AFL 一起执行混合模糊测试。这是基于反馈的模糊测试演变的一个阶段，需要单独讨论。它的主要优点是可以相对快速地进行混合执行。这是由于本机执行命令而没有代码、快照和一些启发式的中间表示。它使用旧版本的Intel pin（由于 libz3 和其他 DBT 之间的支持问题），目前支持ELF x86 和 x86_64 架构</li><li><a href="https://github.com/zhunki/Superion" target="_blank" rel="noopener">Superion</a> — 灰盒模糊测试器，其优点是除了插桩程序外，它还使用 ANTLR 语法获取输入数据的规范，然后在此语法的帮助下执行变异</li><li><a href="https://github.com/aflsmart/aflsmart" target="_blank" rel="noopener">AFLSmart</a> — 另一个灰盒模糊测试器，它以 Peach 使用的格式获得输入数据的规范</li></ul><p>有许多研究论文致力于实现 AFL 被改进的新方法和模糊测试技术。由于它们只有白皮书，所以我们甚至没有提到这些。如果你愿意，你可以搜索它们。例如最新的一些有 <a href="http://chao.100871.net/papers/oakland18.pdf" target="_blank" rel="noopener">CollAFL: Path Sensitive Fuzzing</a>、<a href="https://arxiv.org/pdf/1807.00182.pdf" target="_blank" rel="noopener">EnFuzz</a>、<a href="https://i.blackhat.com/asia-19/Fri-March-29/bh-asia-Dominiak-Efficient-Approach-to-Fuzzing-Interpreters-wp.pdf" target="_blank" rel="noopener">Efficient approach to fuzzing interpreters</a>、<a href="https://arxiv.org/pdf/1811.08973.pdf" target="_blank" rel="noopener">ML</a> 用于 AFL 等。</p><h2 id="基于-QEMU-的改进"><a href="#基于-QEMU-的改进" class="headerlink" title="基于 QEMU 的改进"></a>基于 QEMU 的改进</h2><ul><li><a href="https://github.com/nccgroup/TriforceAFL" target="_blank" rel="noopener">TriforceAFL</a> — AFL/QEMU对系统完全模拟来进行模糊测试。是由 nccgroup 提供的一个分支。它允许在 QEMU 模式下对整个操作系统进行模糊测试。它是通过一个特殊指令（aflCall (0f 24)）（在 QEMU x64 CPU 中添加）实现的。然而它不再受支持; 支持 AFL 的最后一个版本是2.06b</li><li><a href="https://github.com/nccgroup/TriforceLinuxSyscallFuzzer" target="_blank" rel="noopener">TriforceLinuxSyscallFuzzer</a> — Linux 系统调用的模糊测试</li><li><a href="https://github.com/kanglictf/afl-qai" target="_blank" rel="noopener">afl-qai</a> — 一个带有 QEMU 增强插桩（qai）的小型演示项目。</li></ul><h2 id="基于-KLEE-的改进"><a href="#基于-KLEE-的改进" class="headerlink" title="基于 KLEE 的改进"></a>基于 KLEE 的改进</h2><ul><li><a href="https://github.com/julieeen/kleefl" target="_blank" rel="noopener">kleefl</a> — 通过符号执行生成测试用例（在大程序上非常慢）</li></ul><h2 id="基于-Unicorn-的改进"><a href="#基于-Unicorn-的改进" class="headerlink" title="基于 Unicorn 的改进"></a>基于 Unicorn 的改进</h2><ul><li><a href="https://github.com/Battelle/afl-unicorn" target="_blank" rel="noopener">afl-unicorn</a> — 允许通过在 <a href="https://www.unicorn-engine.org/" target="_blank" rel="noopener">Unicorn Engine</a> 上模拟代码片段进行模糊测试</li></ul><p>我们在实践中成功使用了 AFL 的这种改进，由于目标是在 SOC 上执行的某个 RTOS（real-time operating system，实时操作系统）的代码区域，因此我们无法使用QEMU模式。在我们没有源代码的情况下（我们无法构建用于解析器分析的独立二进制文件）并且程序不直接获取输入数据（例如，数据被加密或是如在 CGC 二进制文件中的信号样本），然后我们可以逆向并找到所谓的位置函数，函数中中数据以便于模糊测试器使用的格式进行处理。这是 AFL 最普遍/通用的修改，即它允许模糊测试任何东西。它独立于架构、源、输入数据格式和二进制格式（例如裸机，只是来自控制器内存的代码片段）。研究人员首先检查这个二进制文件并编写一个模糊测试器，它在解析过程的输入端模拟状态。显然与 AFL 不同，这需要对二进制进行一定的检查。对于裸机固件，如 Wi-FI 或基带，我们需要记住一些缺点：</p><ul><li>我们必须本地处理控制和的检查</li><li>模糊测试器的状态是保存在内存转储中的内存状态，这可以防止模糊测试器进入某些路径</li><li>动态内存调用没有消毒，但它可以手动实现，它将取决于 RTOS（必须进行研究）</li><li>未模拟任务内 RTOS 交互，这也可能阻止寻找某些路径</li></ul><p>使用这种修改的例子 <a href="https://hackernoon.com/afl-unicorn-fuzzing-arbitrary-binary-code-563ca28936bf" target="_blank" rel="noopener">afl-unicorn: Fuzzing Arbitrary Binary Code</a> 和 <a href="https://hackernoon.com/afl-unicorn-part-2-fuzzing-the-unfuzzable-bea8de3540a5" target="_blank" rel="noopener">afl-unicorn: Part 2 — Fuzzing the ‘Unfuzzable’</a>。</p><p>在我们继续基于动态二进制检测（DBI）框架进行修改之前，不要忘记这些框架的最快速度由 DynamoRIO，Dynlnst 以及 PIN 实现。</p><h2 id="基于-PIN-的改进"><a href="#基于-PIN-的改进" class="headerlink" title="基于 PIN 的改进"></a>基于 PIN 的改进</h2><ul><li><a href="https://github.com/mothran/aflpin" target="_blank" rel="noopener">aflpin</a> — 采用 Intel PIN 插桩的 AFL</li><li><a href="https://github.com/spinpx/afl_pin_mode" target="_blank" rel="noopener">afl_pin_mode</a> — 另一个采用 Intel PIN 插桩的 AFL</li><li><a href="https://github.com/vanhauser-thc/afl-pin" target="_blank" rel="noopener">afl-pin</a> — 采用 PINtool 的 AFL</li><li><a href="https://github.com/carlosgprado/NaFl" target="_blank" rel="noopener">NaFl</a> — AFL 模糊测试器的克隆（基本核心）</li><li><a href="https://github.com/houcy/PinAFL" target="_blank" rel="noopener">PinAFL</a> — 该工具的作者试图将 AFL 移植到 Windows，以便对已编译的二进制文件进行模糊测试。该项目好像是为了好玩而在一夜之间完成的且未进一步发展。存储库里没有源文件，只有已编译的二进制文件和启动指令。我们不知道它基于哪个版本的 AFL，它只支持 32 位应用程序。</li></ul><p>正如我们所看到的，AFL 有许多不同的修改，但它们在现实生活中并不是非常有用。</p><h2 id="基于-Dyninst-的改进"><a href="#基于-Dyninst-的改进" class="headerlink" title="基于 Dyninst 的改进"></a>基于 Dyninst 的改进</h2><p><a href="https://github.com/talos-vulndev/afl-dyninst" target="_blank" rel="noopener">afl-dyninst</a> — AFL + Dyninst == AFL 黑盒模糊测试。这个版本的特点是首先使用 Duninst 对一个研究过的程序（没有源代码）进行静态插桩（静态二进制插桩，静态二进制重写），然后使用经典 AFL 进行模糊测试，AFL 会认为程序是用 afl-gcc/afl-g++/afl-as 构建的。因此，它在没有源代码的情况下以非常好的生产率工作：与本地编译相比，经典 AFL 是 0.25 倍的速度。与QEMU相比，它具有显着优势：它允许动态链接库的插桩，而 QEMU 只能插桩与库静态链接的基本可执行文件。然而现在它只支持 Linux，如果增加对于 Windows 支持，则需要对 Dyninst 本身进行更改，这个工作<a href="https://github.com/dyninst/dyninst/issues/120" target="_blank" rel="noopener">正在进行</a>中。</p><p>还有另一个<a href="https://github.com/vanhauser-thc/afl-dyninst" target="_blank" rel="noopener">分支</a>具有提升的速度和某些功能（AARCH64 和 PPC 架构的支持）。</p><h2 id="基于-DynamoRIO-的改进"><a href="#基于-DynamoRIO-的改进" class="headerlink" title="基于 DynamoRIO 的改进"></a>基于 DynamoRIO 的改进</h2><ul><li><a href="https://github.com/mxmssh/drAFL" target="_blank" rel="noopener">drAFL</a> — AFl + DynamoRIO – 在 Linux 上没有源代码的模糊测试</li><li><a href="https://github.com/atrosinenko/afl-dr" target="_blank" rel="noopener">afl-dr</a> — 基于 DynamoRIO 的另一种实现，在 <a href="https://habrahabr.ru/post/332076/" target="_blank" rel="noopener">Habr</a> 上有很好的描述</li><li><a href="https://github.com/vanhauser-thc/afl-dynamorio" target="_blank" rel="noopener">afl-dynamorio</a> — 来自 vanhauser-thc 的修改。 据他所说：“当正常的 afl-dyninst 能够使二进制崩溃并且 QEMU 模式 -Q 无法执行时，用 DynamoRIO 运行 AFL。”它支持 ARM 和 AARCH64。DynamoRIO 比 QEMU 慢大约 10 倍，比 dyninst 慢 25 倍，但比 Pintool 快 10 倍。</li><li><a href="https://github.com/ivanfratric/winafl" target="_blank" rel="noopener">WinAFL</a> — 最著名的 AFL分支。（DynamoRIO，也是 syzygy 模式）。这个修改的出现只是时间问题，因为许多人想在 Windows 上尝试 AFL 并将其应用于没有源代码的应用程序。目前，这个工具正在被积极改进，尽管 AFL 代码库（撰写本文时为 2.43b）相对过时，但它都有助于发现多个漏洞（CVE-2016-7212，CVE-2017-0073，CVE- 2017-0190，CVE-2017-11816）。Google Zero Project 团队和 MSRC 漏洞与解决团队的专家正在参与此项目，因此我们希望它能够得到进一步的发展。开发人员使用动态插桩（基于DynamoRIO）而不是编译时插桩，这显着减慢了被分析软件的执行速度，但产生的开销（加倍）与二进制模式下的经典 AFL 相当。他们还解决了快速启动过程的问题，称其为持续模糊测试模式；他们选择对函数进行模糊测试（通过文件内部的偏移或导出表中存在的函数名称）并对其进行插桩，以便可以在循环中调用它，从而启动多个输入数据样本而无需重新启动程序。最近发表的一篇<a href="https://research.checkpoint.com/50-adobe-cves-in-50-days/" target="_blank" rel="noopener">文章</a>描述了作者如何使用 WinAFL 在约 50 天内发现约 50 个漏洞。发布之后很快 WinAFL 就支持 Intel PT（Processor Tracing，处理器跟踪）模式，在这里可以找到<a href="https://github.com/googleprojectzero/winafl/blob/master/readme_pt.md" target="_blank" rel="noopener">细节信息</a>。</li></ul><p>专业读者可能注意到这些改进使用了除了Frida之外的各种流行的插桩框架。 唯一提到 Frida 与 AFL 的结合使用是在 <a href="http://wpage.unina.it/roberto.natella/papers/natella_androidfuzzing_issre2017.pdf" target="_blank" rel="noopener">Chizpurfle: A Gray-Box Android Fuzzer for Vendor Service Customizations</a> 中找到的。 带 Frida 的 AFL 版本非常有用，因为 Frida 支持多种 RISC 架构。</p><p>许多研究者也期待由 Capstone，Unicorn 和 Keystone 的创建者发布的 DBI Scopio 框架。基于这个框架，作者已经创建了一个模糊测试器（Darko），据他们说能够成功地使用它来对嵌入式设备进行模糊测试。有关这方面的更多信息，请参阅 <a href="https://conference.hitb.org/hitbsecconf2018pek/materials/D2T1%20-%20Finding%200days%20in%20Embedded%20Systems%20with%20Code%20Coverage%20Guided%20Fuzzing%20-%20Dr%20Quynh%20and%20Kai%20Jern%20Lau.pdf" target="_blank" rel="noopener">Digging Deep: Finding 0days in Embedded Systems with Code Coverage Guided Fuzzing</a>。</p><h2 id="基于处理器硬件特征的改进"><a href="#基于处理器硬件特征的改进" class="headerlink" title="基于处理器硬件特征的改进"></a>基于处理器硬件特征的改进</h2><p>关于支持处理器硬件功能的 AFL 修改方面，首先，它允许对内核代码进行模糊测试；其次，它允许在没有源代码的情况下更快地对应用程序进行模糊测试。</p><p>当然，谈到处理器硬件功能，我们最感兴趣的是 <a href="https://software.intel.com/en-us/node/721535" target="_blank" rel="noopener">Intel PT</a>。从第 6 代处理器开始（大约自2015年起）支持该功能。 因此，为了能够使用下面列出的模糊测试器，我们需要一个支持 Intel PT 的处理器。</p><ul><li><a href="https://github.com/intelpt/winafl-intelpt" target="_blank" rel="noopener">WinAFL-IntelPT</a> — 使用 Intel PT 而不是 DynamoRIO 的第三方 WinAFL。</li><li><a href="https://github.com/hunter-ht-2018/ptfuzzer" target="_blank" rel="noopener">ptfuzzer</a> - 使用 Intel PT 对二进制进行黑盒测试。</li><li><a href="https://github.com/RUB-SysSec/kAFL" target="_blank" rel="noopener">kAFL</a> — 一个旨在解决独立于操作系统的模糊测试内核时的覆盖率导向问题的学术项目。 它通过使用管理程序（hypervisor）和 Intel PT 来解决该问题。有关它的更多信息可以在白皮书 <a href="https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-schumilo.pdf" target="_blank" rel="noopener">kAFL: Hardware-Assisted Feedback Fuzzing for OS Kernels</a> 中找到。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如你所见，研究人员仍在积极地改进 AFL，而且 AFL 还存在进行实验和创新的空间，我们也可以创建一个我们自己的实用有趣的 AFL。</p><p>感谢阅读，祝大家 Fuzz 顺利。</p><p><a href="https://habr.com/ru/company/dsec/blog/449134/" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;原文标题 Zoo AFL (Apr 24, 2019)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://habr.com/en/users/d1g1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@d1g1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文主要讨论的不是经典 AFL 本身，而是为其设计的工具以及对其本身做出的改进，我们认为这些改进可以显著提高模糊测试的质量。如果你想知道如何提高 AFL 效率以及如何更快地找到更多漏洞，请继续阅读！&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞挖掘" scheme="http://zanderchang.github.io/categories/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="外文翻译" scheme="http://zanderchang.github.io/tags/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
      <category term="漏洞挖掘" scheme="http://zanderchang.github.io/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
      <category term="AFL" scheme="http://zanderchang.github.io/tags/AFL/"/>
    
  </entry>
  
</feed>
